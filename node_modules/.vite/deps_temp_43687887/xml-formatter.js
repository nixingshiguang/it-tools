import {
  __commonJS
} from "./chunk-2LSFTFF7.js";

// node_modules/.pnpm/xml-parser-xo@4.0.5/node_modules/xml-parser-xo/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/.pnpm/xml-parser-xo@4.0.5/node_modules/xml-parser-xo/dist/cjs/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsingError = void 0;
    var ParsingError = class extends Error {
      constructor(message, cause) {
        super(message);
        this.cause = cause;
      }
    };
    exports.ParsingError = ParsingError;
    var parsingState;
    function nextChild() {
      return element(false) || text() || comment() || cdata();
    }
    function nextRootChild() {
      match(/\s*/);
      return element(true) || comment() || doctype() || processingInstruction(false);
    }
    function parseDocument() {
      const declaration = processingInstruction(true);
      const children = [];
      let documentRootNode;
      let child = nextRootChild();
      while (child) {
        if (child.node.type === "Element") {
          if (documentRootNode) {
            throw new Error("Found multiple root nodes");
          }
          documentRootNode = child.node;
        }
        if (!child.excluded) {
          children.push(child.node);
        }
        child = nextRootChild();
      }
      if (!documentRootNode) {
        throw new ParsingError("Failed to parse XML", "Root Element not found");
      }
      if (parsingState.xml.length !== 0) {
        throw new ParsingError("Failed to parse XML", "Not Well-Formed XML");
      }
      return {
        declaration: declaration ? declaration.node : null,
        root: documentRootNode,
        children
      };
    }
    function processingInstruction(matchDeclaration) {
      const m = matchDeclaration ? match(/^<\?(xml)\s*/) : match(/^<\?([\w-:.]+)\s*/);
      if (!m)
        return;
      const node = {
        name: m[1],
        type: "ProcessingInstruction",
        attributes: {}
      };
      while (!(eos() || is("?>"))) {
        const attr = attribute();
        if (attr) {
          node.attributes[attr.name] = attr.value;
        } else {
          return;
        }
      }
      match(/\?>/);
      return {
        excluded: matchDeclaration ? false : parsingState.options.filter(node) === false,
        node
      };
    }
    function element(matchRoot) {
      const m = match(/^<([^?!</>\s]+)\s*/);
      if (!m)
        return;
      const node = {
        type: "Element",
        name: m[1],
        attributes: {},
        children: []
      };
      const excluded = matchRoot ? false : parsingState.options.filter(node) === false;
      while (!(eos() || is(">") || is("?>") || is("/>"))) {
        const attr = attribute();
        if (attr) {
          node.attributes[attr.name] = attr.value;
        } else {
          return;
        }
      }
      if (match(/^\s*\/>/)) {
        node.children = null;
        return {
          excluded,
          node
        };
      }
      match(/\??>/);
      let child = nextChild();
      while (child) {
        if (!child.excluded) {
          node.children.push(child.node);
        }
        child = nextChild();
      }
      match(/^<\/\s*[\w-:.\u00C0-\u00FF]+>/);
      return {
        excluded,
        node
      };
    }
    function doctype() {
      const m = match(/^<!DOCTYPE\s+[^>]*>/);
      if (m) {
        const node = {
          type: "DocumentType",
          content: m[0]
        };
        return {
          excluded: parsingState.options.filter(node) === false,
          node
        };
      }
    }
    function cdata() {
      if (parsingState.xml.startsWith("<![CDATA[")) {
        const endPositionStart = parsingState.xml.indexOf("]]>");
        if (endPositionStart > -1) {
          const endPositionFinish = endPositionStart + 3;
          const node = {
            type: "CDATA",
            content: parsingState.xml.substring(0, endPositionFinish)
          };
          parsingState.xml = parsingState.xml.slice(endPositionFinish);
          return {
            excluded: parsingState.options.filter(node) === false,
            node
          };
        }
      }
    }
    function comment() {
      const m = match(/^<!--[\s\S]*?-->/);
      if (m) {
        const node = {
          type: "Comment",
          content: m[0]
        };
        return {
          excluded: parsingState.options.filter(node) === false,
          node
        };
      }
    }
    function text() {
      const m = match(/^([^<]+)/);
      if (m) {
        const node = {
          type: "Text",
          content: m[1]
        };
        return {
          excluded: parsingState.options.filter(node) === false,
          node
        };
      }
    }
    function attribute() {
      const m = match(/([^=]+)\s*=\s*("[^"]*"|'[^']*'|[^>\s]+)\s*/);
      if (m) {
        return {
          name: m[1].trim(),
          value: stripQuotes(m[2].trim())
        };
      }
    }
    function stripQuotes(val) {
      return val.replace(/^['"]|['"]$/g, "");
    }
    function match(re) {
      const m = parsingState.xml.match(re);
      if (m) {
        parsingState.xml = parsingState.xml.slice(m[0].length);
        return m;
      }
    }
    function eos() {
      return 0 === parsingState.xml.length;
    }
    function is(prefix) {
      return 0 === parsingState.xml.indexOf(prefix);
    }
    function parseXml(xml, options = {}) {
      xml = xml.trim();
      const filter = options.filter || (() => true);
      parsingState = {
        xml,
        options: Object.assign(Object.assign({}, options), { filter })
      };
      return parseDocument();
    }
    if (typeof module !== "undefined" && typeof exports === "object") {
      module.exports = parseXml;
    }
    exports.default = parseXml;
  }
});

// node_modules/.pnpm/xml-formatter@3.3.2/node_modules/xml-formatter/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/.pnpm/xml-formatter@3.3.2/node_modules/xml-formatter/dist/cjs/index.js"(exports, module) {
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var xml_parser_xo_1 = __importDefault(require_cjs());
    function newLine(state) {
      if (!state.options.indentation && !state.options.lineSeparator)
        return;
      state.content += state.options.lineSeparator;
      let i;
      for (i = 0; i < state.level; i++) {
        state.content += state.options.indentation;
      }
    }
    function appendContent(state, content) {
      state.content += content;
    }
    function processNode(node, state, preserveSpace) {
      if (typeof node.content === "string") {
        processContent(node.content, state, preserveSpace);
      } else if (node.type === "Element") {
        processElementNode(node, state, preserveSpace);
      } else if (node.type === "ProcessingInstruction") {
        processProcessingIntruction(node, state);
      } else {
        throw new Error("Unknown node type: " + node.type);
      }
    }
    function processContent(content, state, preserveSpace) {
      if (!preserveSpace) {
        const trimmedContent = content.trim();
        if (state.options.lineSeparator) {
          content = trimmedContent;
        } else if (trimmedContent.length === 0) {
          content = trimmedContent;
        }
      }
      if (content.length > 0) {
        if (!preserveSpace && state.content.length > 0) {
          newLine(state);
        }
        appendContent(state, content);
      }
    }
    function processElementNode(node, state, preserveSpace) {
      if (!preserveSpace && state.content.length > 0) {
        newLine(state);
      }
      appendContent(state, "<" + node.name);
      processAttributes(state, node.attributes);
      if (node.children === null) {
        const selfClosingNodeClosingTag = state.options.whiteSpaceAtEndOfSelfclosingTag ? " />" : "/>";
        appendContent(state, selfClosingNodeClosingTag);
      } else if (node.children.length === 0) {
        appendContent(state, "></" + node.name + ">");
      } else {
        const nodeChildren = node.children;
        appendContent(state, ">");
        state.level++;
        let nodePreserveSpace = node.attributes["xml:space"] === "preserve";
        if (!nodePreserveSpace && state.options.collapseContent) {
          let containsTextNodes = false;
          let containsTextNodesWithLineBreaks = false;
          let containsNonTextNodes = false;
          nodeChildren.forEach(function(child, index) {
            if (child.type === "Text") {
              if (child.content.includes("\n")) {
                containsTextNodesWithLineBreaks = true;
                child.content = child.content.trim();
              } else if (index === 0 || index === nodeChildren.length - 1) {
                if (child.content.trim().length === 0) {
                  child.content = "";
                }
              }
              if (child.content.trim().length > 0) {
                containsTextNodes = true;
              }
            } else if (child.type === "CDATA") {
              containsTextNodes = true;
            } else {
              containsNonTextNodes = true;
            }
          });
          if (containsTextNodes && (!containsNonTextNodes || !containsTextNodesWithLineBreaks)) {
            nodePreserveSpace = true;
          }
        }
        nodeChildren.forEach(function(child) {
          processNode(child, state, preserveSpace || nodePreserveSpace);
        });
        state.level--;
        if (!preserveSpace && !nodePreserveSpace) {
          newLine(state);
        }
        appendContent(state, "</" + node.name + ">");
      }
    }
    function processAttributes(state, attributes) {
      Object.keys(attributes).forEach(function(attr) {
        const escaped = attributes[attr].replace(/"/g, "&quot;");
        appendContent(state, " " + attr + '="' + escaped + '"');
      });
    }
    function processProcessingIntruction(node, state) {
      if (state.content.length > 0) {
        newLine(state);
      }
      appendContent(state, "<?" + node.name);
      processAttributes(state, node.attributes);
      appendContent(state, "?>");
    }
    function formatXml(xml, options = {}) {
      options.indentation = "indentation" in options ? options.indentation : "    ";
      options.collapseContent = options.collapseContent === true;
      options.lineSeparator = "lineSeparator" in options ? options.lineSeparator : "\r\n";
      options.whiteSpaceAtEndOfSelfclosingTag = options.whiteSpaceAtEndOfSelfclosingTag === true;
      options.throwOnFailure = options.throwOnFailure !== false;
      try {
        const parsedXml = (0, xml_parser_xo_1.default)(xml, { filter: options.filter });
        const state = { content: "", level: 0, options };
        if (parsedXml.declaration) {
          processProcessingIntruction(parsedXml.declaration, state);
        }
        parsedXml.children.forEach(function(child) {
          processNode(child, state, false);
        });
        if (!options.lineSeparator) {
          return state.content;
        }
        return state.content.replace(/\r\n/g, "\n").replace(/\n/g, options.lineSeparator);
      } catch (err) {
        if (options.throwOnFailure) {
          throw err;
        }
        return xml;
      }
    }
    formatXml.minify = (xml, options = {}) => {
      return formatXml(xml, Object.assign(Object.assign({}, options), { indentation: "", lineSeparator: "" }));
    };
    if (typeof module !== "undefined" && typeof exports === "object") {
      module.exports = formatXml;
    }
    exports.default = formatXml;
  }
});
export default require_cjs2();
//# sourceMappingURL=xml-formatter.js.map
