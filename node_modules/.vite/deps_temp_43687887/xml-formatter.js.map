{
  "version": 3,
  "sources": ["../../.pnpm/xml-parser-xo@4.0.5/node_modules/xml-parser-xo/src/index.ts", "../../.pnpm/xml-formatter@3.3.2/node_modules/xml-formatter/src/index.ts"],
  "sourcesContent": ["export type XmlParserOptions = {\n    /**\n     * Returns false to exclude a node. Default is true.\n     */\n    filter?: (node: XmlParserNode) => boolean|any;\n};\n\nexport type XmlParserNodeType = 'Comment'|'Text'|'ProcessingInstruction'|'Element'|'DocumentType'|'CDATA';\n\nexport type XmlParserNodeWrapper<T extends XmlParserNode> = {\n    excluded: boolean;\n    node: T;\n}\n\nexport type XmlParserNode = {\n    type: XmlParserNodeType;\n}\n\nexport type XmlParserAttribute = {\n    name: string;\n    value: string;\n}\n\nexport type XmlParserElementChildNode = XmlParserTextNode|XmlParserElementNode|XmlParserCDATANode|XmlParserCommentNode;\nexport type XmlParserDocumentChildNode = XmlParserDocumentTypeNode|XmlParserProcessingInstructionNode|XmlParserElementChildNode;\n\nexport type XmlParserProcessingInstructionNode = {\n    type: 'ProcessingInstruction';\n    name: string;\n    attributes: Record<string, string>;\n}\n\n\nexport type XmlParserElementNode = {\n    type: 'Element';\n    name: string;\n    attributes: Record<string, string>;\n    children: XmlParserElementChildNode[]|null;\n}\n\nexport type XmlParserTextNode = {\n    type: 'Text';\n    content: string;\n}\n\nexport type XmlParserCDATANode = {\n    type: 'CDATA';\n    content: string;\n}\n\nexport type XmlParserCommentNode = {\n    type: 'Comment';\n    content: string;\n}\n\nexport type XmlParserDocumentTypeNode = {\n    type: 'DocumentType';\n    content: string;\n}\n\nexport type XmlParserResult = {\n    declaration?: XmlParserProcessingInstructionNode|null;\n    root: XmlParserElementNode;\n    children: XmlParserDocumentChildNode[];\n};\n\nexport class ParsingError extends Error {\n\n    public readonly cause: string;\n\n    public constructor(message: string, cause: string) {\n        super(message);\n        this.cause = cause;\n    }\n}\n\nlet parsingState: {\n    xml: string;\n    options: Required<XmlParserOptions>;\n};\n\nfunction nextChild() {\n    return element(false) || text() || comment() || cdata();\n}\n\nfunction nextRootChild() {\n    match(/\\s*/);\n    return element(true) || comment() || doctype() || processingInstruction(false);\n}\n\nfunction parseDocument(): XmlParserResult {\n    const declaration = processingInstruction(true);\n    const children = [];\n    let documentRootNode;\n    let child = nextRootChild();\n\n    while (child) {\n        if (child.node.type === 'Element') {\n            if (documentRootNode) {\n                throw new Error('Found multiple root nodes');\n            }\n            documentRootNode = child.node;\n        }\n\n        if (!child.excluded) {\n            children.push(child.node);\n        }\n\n        child = nextRootChild();\n    }\n\n    if (!documentRootNode) {\n        throw new ParsingError('Failed to parse XML', 'Root Element not found');\n    }\n\n    if (parsingState.xml.length !== 0) {\n        throw new ParsingError('Failed to parse XML', 'Not Well-Formed XML');\n    }\n\n    return {\n        declaration: declaration ? declaration.node : null,\n        root: documentRootNode,\n        children\n    };\n}\n\nfunction processingInstruction(matchDeclaration: boolean): XmlParserNodeWrapper<XmlParserProcessingInstructionNode>|undefined {\n    const m = matchDeclaration ? match(/^<\\?(xml)\\s*/) : match(/^<\\?([\\w-:.]+)\\s*/);\n    if (!m) return;\n\n    // tag\n    const node: XmlParserProcessingInstructionNode = {\n        name: m[1],\n        type: 'ProcessingInstruction',\n        attributes: {}\n    };\n\n    // attributes\n    while (!(eos() || is('?>'))) {\n        const attr = attribute();\n        if (attr) {\n            node.attributes[attr.name] = attr.value;\n        } else {\n            return;\n        }\n    }\n\n    match(/\\?>/);\n\n    return {\n        excluded: matchDeclaration ? false : parsingState.options.filter(node) === false,\n        node\n    };\n}\n\nfunction element(matchRoot: boolean): XmlParserNodeWrapper<XmlParserElementNode>|undefined {\n    const m = match(/^<([^?!</>\\s]+)\\s*/);\n    if (!m) return;\n\n    // name\n    const node: XmlParserElementNode = {\n        type: 'Element',\n        name: m[1],\n        attributes: {},\n        children: []\n    };\n\n    const excluded = matchRoot ? false : parsingState.options.filter(node) === false;\n\n    // attributes\n    while (!(eos() || is('>') || is('?>') || is('/>'))) {\n        const attr = attribute();\n        if (attr) {\n            node.attributes[attr.name] = attr.value;\n        } else {\n            return;\n        }\n    }\n\n    // self closing tag\n    if (match(/^\\s*\\/>/)) {\n        node.children = null;\n        return {\n            excluded,\n            node\n        };\n    }\n\n    match(/\\??>/);\n\n    // children\n    let child = nextChild();\n    while (child) {\n        if (!child.excluded) {\n            node.children!.push(child.node);\n        }\n        child = nextChild();\n    }\n\n    // closing\n    match(/^<\\/\\s*[\\w-:.\\u00C0-\\u00FF]+>/);\n\n    return {\n        excluded,\n        node\n    };\n}\n\nfunction doctype(): XmlParserNodeWrapper<XmlParserDocumentTypeNode>|undefined {\n    const m = match(/^<!DOCTYPE\\s+[^>]*>/);\n    if (m) {\n        const node: XmlParserDocumentTypeNode = {\n            type: 'DocumentType',\n            content: m[0]\n        };\n        return {\n            excluded: parsingState.options.filter(node) === false,\n            node\n        };\n    }\n}\n\nfunction cdata(): XmlParserNodeWrapper<XmlParserCDATANode>|undefined {\n    if (parsingState.xml.startsWith('<![CDATA[')) {\n        const endPositionStart = parsingState.xml.indexOf(']]>');\n        if (endPositionStart > -1) {\n            const endPositionFinish  = endPositionStart + 3;\n            const node: XmlParserCDATANode = {\n                type: 'CDATA',\n                content: parsingState.xml.substring(0, endPositionFinish)\n            };\n            parsingState.xml = parsingState.xml.slice(endPositionFinish);\n            return {\n                excluded: parsingState.options.filter(node) === false,\n                node\n            };\n        }\n    }\n}\n\nfunction comment(): XmlParserNodeWrapper<XmlParserCommentNode>|undefined {\n    const m = match(/^<!--[\\s\\S]*?-->/);\n    if (m) {\n        const node: XmlParserCommentNode = {\n            type: 'Comment',\n            content: m[0]\n        };\n        return {\n            excluded: parsingState.options.filter(node) === false,\n            node\n        };\n    }\n}\n\nfunction text(): XmlParserNodeWrapper<XmlParserTextNode>|undefined {\n    const m = match(/^([^<]+)/);\n    if (m) {\n        const node: XmlParserTextNode = {\n            type: 'Text',\n            content: m[1]\n        };\n        return {\n            excluded: parsingState.options.filter(node) === false,\n            node\n        };\n    }\n}\n\nfunction attribute(): XmlParserAttribute|undefined {\n    const m = match(/([^=]+)\\s*=\\s*(\"[^\"]*\"|'[^']*'|[^>\\s]+)\\s*/);\n    if (m) {\n        return {\n            name: m[1].trim(),\n            value: stripQuotes(m[2].trim())\n        };\n    }\n}\n\nfunction stripQuotes(val: string): string {\n    return val.replace(/^['\"]|['\"]$/g, '');\n}\n\n/**\n * Match `re` and advance the string.\n */\nfunction match(re: RegExp): RegExpMatchArray|undefined {\n    const m = parsingState.xml.match(re);\n    if (m) {\n        parsingState.xml = parsingState.xml.slice(m[0].length);\n        return m;\n    }\n}\n\n/**\n * End-of-source.\n */\nfunction eos(): boolean {\n    return 0 === parsingState.xml.length;\n}\n\n/**\n * Check for `prefix`.\n */\nfunction is(prefix: string): boolean {\n    return 0 === parsingState.xml.indexOf(prefix);\n}\n\n/**\n * Parse the given XML string into an object.\n */\nfunction parseXml(xml: string, options: XmlParserOptions = {}): XmlParserResult {\n\n    xml = xml.trim();\n\n    const filter: XmlParserOptions['filter'] = options.filter || (() => true);\n\n    parsingState = {\n        xml,\n        options: {\n            ...options,\n            filter\n        }\n    };\n\n    return parseDocument();\n}\n\nif (typeof module !== 'undefined' && typeof exports === 'object') {\n    module.exports = parseXml;\n}\n\nexport default parseXml;\n", "import xmlParser, {\n    XmlParserElementNode,\n    XmlParserNode,\n    XmlParserProcessingInstructionNode,\n    XmlParserDocumentChildNode,\n    XmlParserElementChildNode\n} from 'xml-parser-xo';\n\nexport type XMLFormatterOptions = {\n\n    /**\n     * The value used for indentation.\n     * Default = '    '\n     */\n    indentation?: string;\n\n    /**\n     * Return false to exclude the node.\n     */\n    filter?: (node: XmlParserNode) => boolean;\n\n    /**\n     * True to keep content in the same line as the element.\n     * Notes: Only works if element contains at least one text node.\n     * Default: false\n     */\n    collapseContent?: boolean;\n\n    /**\n     * The line separator to use.\n     * Default: '\\r\\n'\n     */\n    lineSeparator?: string;\n\n    /**\n     * To either end ad self closing tag with `<tag/>` or `<tag />`.\n     * Default: false\n     */\n    whiteSpaceAtEndOfSelfclosingTag?: boolean;\n\n    /**\n     * Throw an error when XML fails to parse and get formatted.\n     * Notes: If set to `false`, the original XML is returned when an error occurs.\n     * Default: true\n     */\n    throwOnFailure?: boolean;\n};\n\nexport type XMLFormatterMinifyOptions = Omit<XMLFormatterOptions, 'lineSeparator'|'indentation'>;\n\ntype XMLFormatterState = {\n    content: string;\n    level: number;\n    options: XMLFormatterOptions;\n};\n\nfunction newLine(state: XMLFormatterState): void {\n    if (!state.options.indentation && !state.options.lineSeparator) return;\n    state.content += state.options.lineSeparator;\n    let i;\n    for (i = 0; i < state.level; i++) {\n        state.content += state.options.indentation;\n    }\n}\n\nfunction appendContent(state: XMLFormatterState, content: string): void {\n    state.content += content;\n}\n\nfunction processNode(node: XmlParserNode, state: XMLFormatterState, preserveSpace: boolean): void {\n    if (typeof (node as any).content === 'string') {\n        processContent((node as any).content, state, preserveSpace);\n    } else if (node.type === 'Element') {\n        processElementNode(node as XmlParserElementNode, state, preserveSpace);\n    } else if (node.type === 'ProcessingInstruction') {\n        processProcessingIntruction(node as XmlParserProcessingInstructionNode, state);\n    } else {\n        throw new Error('Unknown node type: ' + node.type);\n    }\n}\n\nfunction processContent(content: string, state: XMLFormatterState, preserveSpace: boolean): void {\n    if (!preserveSpace) {\n        const trimmedContent = content.trim();\n        if (state.options.lineSeparator) {\n            content = trimmedContent;\n        } else if (trimmedContent.length === 0) {\n            content = trimmedContent;\n        }\n    }\n    if (content.length > 0) {\n        if (!preserveSpace && state.content.length > 0) {\n            newLine(state);\n        }\n        appendContent(state, content);\n    }\n}\n\nfunction processElementNode(node: XmlParserElementNode, state: XMLFormatterState, preserveSpace: boolean): void {\n    if (!preserveSpace && state.content.length > 0) {\n        newLine(state);\n    }\n\n    appendContent(state, '<' + node.name);\n    processAttributes(state, node.attributes);\n\n    if (node.children === null) {\n        const selfClosingNodeClosingTag = state.options.whiteSpaceAtEndOfSelfclosingTag ? ' />' : '/>'\n        // self-closing node\n        appendContent(state, selfClosingNodeClosingTag);\n    } else if (node.children.length === 0) {\n        // empty node\n        appendContent(state, '></' + node.name + '>');\n    } else {\n\n        const nodeChildren = node.children;\n\n        appendContent(state, '>');\n\n        state.level++;\n\n        let nodePreserveSpace = node.attributes['xml:space'] === 'preserve';\n\n        if (!nodePreserveSpace && state.options.collapseContent) {\n            let containsTextNodes = false;\n            let containsTextNodesWithLineBreaks = false;\n            let containsNonTextNodes = false;\n\n            nodeChildren.forEach(function(child: XmlParserElementChildNode, index: number) {\n                if (child.type === 'Text') {\n                    if (child.content.includes('\\n')) {\n                        containsTextNodesWithLineBreaks = true;\n                        child.content = child.content.trim();\n                    } else if (index === 0 || index === nodeChildren.length - 1) {\n                        if (child.content.trim().length === 0) {\n                            // If the text node is at the start or end and is empty, it should be ignored when formatting\n                            child.content = '';\n                        }\n                    }\n                    if (child.content.trim().length > 0) {\n                        containsTextNodes = true;\n                    }\n                } else if (child.type === 'CDATA') {\n                    containsTextNodes = true;\n                } else {\n                    containsNonTextNodes = true;\n                }\n            });\n\n            if (containsTextNodes && (!containsNonTextNodes || !containsTextNodesWithLineBreaks)) {\n                nodePreserveSpace = true;\n            }\n        }\n\n        nodeChildren.forEach(function(child: XmlParserElementChildNode) {\n            processNode(child, state, preserveSpace || nodePreserveSpace);\n        });\n\n        state.level--;\n\n        if (!preserveSpace && !nodePreserveSpace) {\n            newLine(state);\n        }\n        appendContent(state, '</' + node.name + '>');\n    }\n}\n\nfunction processAttributes(state: XMLFormatterState, attributes: Record<string, string>): void {\n    Object.keys(attributes).forEach(function(attr) {\n        const escaped = attributes[attr].replace(/\"/g, '&quot;');\n        appendContent(state, ' ' + attr + '=\"' + escaped + '\"');\n    });\n}\n\nfunction processProcessingIntruction(node: XmlParserProcessingInstructionNode, state: XMLFormatterState): void {\n    if (state.content.length > 0) {\n        newLine(state);\n    }\n    appendContent(state, '<?' + node.name);\n    processAttributes(state, node.attributes);\n    appendContent(state, '?>');\n}\n\n\n/**\n * Converts the given XML into human readable format.\n */\nfunction formatXml(xml: string, options: XMLFormatterOptions = {}): string {\n    options.indentation = 'indentation' in options ? options.indentation : '    ';\n    options.collapseContent = options.collapseContent === true;\n    options.lineSeparator = 'lineSeparator' in options ? options.lineSeparator : '\\r\\n';\n    options.whiteSpaceAtEndOfSelfclosingTag = options.whiteSpaceAtEndOfSelfclosingTag === true;\n    options.throwOnFailure = options.throwOnFailure !== false;\n\n    try {\n        const parsedXml = xmlParser(xml, {filter: options.filter});\n        const state = {content: '', level: 0, options: options};\n\n        if (parsedXml.declaration) {\n            processProcessingIntruction(parsedXml.declaration, state);\n        }\n\n        parsedXml.children.forEach(function (child: XmlParserDocumentChildNode) {\n            processNode(child, state, false);\n        });\n\n        if (!options.lineSeparator) {\n            return state.content;\n        }\n\n        return state.content\n            .replace(/\\r\\n/g, '\\n')\n            .replace(/\\n/g, options.lineSeparator as string);\n    } catch (err) {\n        if (options.throwOnFailure) {\n            throw err;\n        }\n        return xml;\n    }\n}\n\nformatXml.minify = (xml: string, options: XMLFormatterMinifyOptions = {}) => {\n    return formatXml(xml, {...options, indentation: '', lineSeparator: ''});\n}\n\nif (typeof module !== 'undefined' && typeof exports === 'object') {\n    module.exports = formatXml;\n}\n\nexport default formatXml;\n"],
  "mappings": "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",
  "names": []
}
