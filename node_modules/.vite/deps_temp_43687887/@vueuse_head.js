import {
  debouncedRenderDOMHead,
  renderDOMHead
} from "./chunk-NFPCTUSH.js";
import "./chunk-NQAK2E44.js";
import {
  defineComponent,
  getCurrentInstance,
  inject,
  nextTick,
  onBeforeUnmount,
  ref,
  unref,
  version,
  watch,
  watchEffect
} from "./chunk-INQX4MOS.js";
import "./chunk-2LSFTFF7.js";

// node_modules/.pnpm/@vueuse+shared@12.0.0_typescript@5.2.2/node_modules/@vueuse/shared/index.mjs
function toValue(r) {
  return typeof r === "function" ? r() : unref(r);
}
var resolveUnref = toValue;
var isClient = typeof window !== "undefined" && typeof document !== "undefined";
var isWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var isIOS = getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function cacheStringFunction(fn) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});

// node_modules/.pnpm/hookable@5.5.3/node_modules/hookable/dist/index.mjs
function flatHooks(configHooks, hooks = {}, parentName) {
  for (const key in configHooks) {
    const subHook = configHooks[key];
    const name = parentName ? `${parentName}:${key}` : key;
    if (typeof subHook === "object" && subHook !== null) {
      flatHooks(subHook, hooks, name);
    } else if (typeof subHook === "function") {
      hooks[name] = subHook;
    }
  }
  return hooks;
}
var defaultTask = { run: (function_) => function_() };
var _createTask = () => defaultTask;
var createTask = typeof console.createTask !== "undefined" ? console.createTask : _createTask;
function serialTaskCaller(hooks, args) {
  const name = args.shift();
  const task = createTask(name);
  return hooks.reduce(
    (promise, hookFunction) => promise.then(() => task.run(() => hookFunction(...args))),
    Promise.resolve()
  );
}
function parallelTaskCaller(hooks, args) {
  const name = args.shift();
  const task = createTask(name);
  return Promise.all(hooks.map((hook) => task.run(() => hook(...args))));
}
function callEachWith(callbacks, arg0) {
  for (const callback of [...callbacks]) {
    callback(arg0);
  }
}
var Hookable = class {
  constructor() {
    this._hooks = {};
    this._before = void 0;
    this._after = void 0;
    this._deprecatedMessages = void 0;
    this._deprecatedHooks = {};
    this.hook = this.hook.bind(this);
    this.callHook = this.callHook.bind(this);
    this.callHookWith = this.callHookWith.bind(this);
  }
  hook(name, function_, options = {}) {
    if (!name || typeof function_ !== "function") {
      return () => {
      };
    }
    const originalName = name;
    let dep;
    while (this._deprecatedHooks[name]) {
      dep = this._deprecatedHooks[name];
      name = dep.to;
    }
    if (dep && !options.allowDeprecated) {
      let message = dep.message;
      if (!message) {
        message = `${originalName} hook has been deprecated` + (dep.to ? `, please use ${dep.to}` : "");
      }
      if (!this._deprecatedMessages) {
        this._deprecatedMessages = /* @__PURE__ */ new Set();
      }
      if (!this._deprecatedMessages.has(message)) {
        console.warn(message);
        this._deprecatedMessages.add(message);
      }
    }
    if (!function_.name) {
      try {
        Object.defineProperty(function_, "name", {
          get: () => "_" + name.replace(/\W+/g, "_") + "_hook_cb",
          configurable: true
        });
      } catch {
      }
    }
    this._hooks[name] = this._hooks[name] || [];
    this._hooks[name].push(function_);
    return () => {
      if (function_) {
        this.removeHook(name, function_);
        function_ = void 0;
      }
    };
  }
  hookOnce(name, function_) {
    let _unreg;
    let _function = (...arguments_) => {
      if (typeof _unreg === "function") {
        _unreg();
      }
      _unreg = void 0;
      _function = void 0;
      return function_(...arguments_);
    };
    _unreg = this.hook(name, _function);
    return _unreg;
  }
  removeHook(name, function_) {
    if (this._hooks[name]) {
      const index = this._hooks[name].indexOf(function_);
      if (index !== -1) {
        this._hooks[name].splice(index, 1);
      }
      if (this._hooks[name].length === 0) {
        delete this._hooks[name];
      }
    }
  }
  deprecateHook(name, deprecated) {
    this._deprecatedHooks[name] = typeof deprecated === "string" ? { to: deprecated } : deprecated;
    const _hooks = this._hooks[name] || [];
    delete this._hooks[name];
    for (const hook of _hooks) {
      this.hook(name, hook);
    }
  }
  deprecateHooks(deprecatedHooks) {
    Object.assign(this._deprecatedHooks, deprecatedHooks);
    for (const name in deprecatedHooks) {
      this.deprecateHook(name, deprecatedHooks[name]);
    }
  }
  addHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    const removeFns = Object.keys(hooks).map(
      (key) => this.hook(key, hooks[key])
    );
    return () => {
      for (const unreg of removeFns.splice(0, removeFns.length)) {
        unreg();
      }
    };
  }
  removeHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    for (const key in hooks) {
      this.removeHook(key, hooks[key]);
    }
  }
  removeAllHooks() {
    for (const key in this._hooks) {
      delete this._hooks[key];
    }
  }
  callHook(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(serialTaskCaller, name, ...arguments_);
  }
  callHookParallel(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(parallelTaskCaller, name, ...arguments_);
  }
  callHookWith(caller, name, ...arguments_) {
    const event = this._before || this._after ? { name, args: arguments_, context: {} } : void 0;
    if (this._before) {
      callEachWith(this._before, event);
    }
    const result = caller(
      name in this._hooks ? [...this._hooks[name]] : [],
      arguments_
    );
    if (result instanceof Promise) {
      return result.finally(() => {
        if (this._after && event) {
          callEachWith(this._after, event);
        }
      });
    }
    if (this._after && event) {
      callEachWith(this._after, event);
    }
    return result;
  }
  beforeEach(function_) {
    this._before = this._before || [];
    this._before.push(function_);
    return () => {
      if (this._before !== void 0) {
        const index = this._before.indexOf(function_);
        if (index !== -1) {
          this._before.splice(index, 1);
        }
      }
    };
  }
  afterEach(function_) {
    this._after = this._after || [];
    this._after.push(function_);
    return () => {
      if (this._after !== void 0) {
        const index = this._after.indexOf(function_);
        if (index !== -1) {
          this._after.splice(index, 1);
        }
      }
    };
  }
};
function createHooks() {
  return new Hookable();
}

// node_modules/.pnpm/unhead@0.5.1/node_modules/unhead/dist/index.mjs
var HasElementTags = [
  "base",
  "meta",
  "link",
  "style",
  "script",
  "noscript"
];
var ValidHeadTags = [
  "title",
  "titleTemplate",
  "base",
  "htmlAttrs",
  "bodyAttrs",
  "meta",
  "link",
  "style",
  "script",
  "noscript"
];
var TagConfigKeys = ["tagPosition", "tagPriority", "tagDuplicateStrategy"];
function normaliseTag(tagName, input) {
  const tag = { tag: tagName, props: {} };
  if (tagName === "title" || tagName === "titleTemplate") {
    tag.children = input;
    return tag;
  }
  tag.props = normaliseProps({ ...input });
  ["children", "innerHtml", "innerHTML"].forEach((key) => {
    if (typeof tag.props[key] !== "undefined") {
      tag.children = tag.props[key];
      delete tag.props[key];
    }
  });
  Object.keys(tag.props).filter((k) => TagConfigKeys.includes(k)).forEach((k) => {
    tag[k] = tag.props[k];
    delete tag.props[k];
  });
  if (typeof tag.props.class === "object" && !Array.isArray(tag.props.class)) {
    tag.props.class = Object.keys(tag.props.class).filter((k) => tag.props.class[k]);
  }
  if (Array.isArray(tag.props.class))
    tag.props.class = tag.props.class.join(" ");
  if (tag.props.content && Array.isArray(tag.props.content)) {
    return tag.props.content.map((v, i) => {
      const newTag = { ...tag, props: { ...tag.props } };
      newTag.props.content = v;
      newTag.key = `${tag.props.name || tag.props.property}:${i}`;
      return newTag;
    });
  }
  return tag;
}
function normaliseProps(props) {
  for (const k in props) {
    if (String(props[k]) === "true") {
      props[k] = "";
    } else if (String(props[k]) === "false") {
      delete props[k];
    }
  }
  return props;
}
var tagWeight = (tag) => {
  if (typeof tag.tagPriority === "number")
    return tag.tagPriority;
  switch (tag.tag) {
    case "base":
      return -1;
    case "title":
      return 1;
    case "meta":
      if (tag.props.charset)
        return -2;
      if (tag.props["http-equiv"] === "content-security-policy")
        return 0;
      return 10;
    default:
      return 10;
  }
};
var sortTags = (aTag, bTag) => {
  return tagWeight(aTag) - tagWeight(bTag);
};
var UniqueTags = ["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs"];
var ArrayMetaProperties = [
  "og:image",
  "og:video",
  "og:audio",
  "og:locale:alternate",
  "video:actor",
  "video:director",
  "video:writer",
  "video:tag",
  "article:author",
  "article:tag",
  "book:tag",
  "book:author",
  "music:album",
  "music:musician"
];
function tagDedupeKey(tag) {
  const { props, tag: tagName } = tag;
  if (UniqueTags.includes(tagName))
    return tagName;
  if (tagName === "link" && props.rel === "canonical")
    return "canonical";
  if (props.charset)
    return "charset";
  const name = ["id"];
  if (tagName === "meta")
    name.push(...["name", "property", "http-equiv"]);
  for (const n of name) {
    if (typeof props[n] !== "undefined") {
      const val = String(props[n]);
      if (ArrayMetaProperties.findIndex((p) => val.startsWith(p)) !== -1)
        return false;
      return `${tagName}:${n}:${val}`;
    }
  }
  return false;
}
var renderTitleTemplate = (template, title) => {
  if (template == null)
    return title || null;
  if (typeof template === "function")
    return template(title);
  return template.replace("%s", title ?? "");
};
function resolveTitleTemplateFromTags(tags) {
  const titleTemplateIdx = tags.findIndex((i) => i.tag === "titleTemplate");
  const titleIdx = tags.findIndex((i) => i.tag === "title");
  if (titleIdx !== -1 && titleTemplateIdx !== -1) {
    const newTitle = renderTitleTemplate(
      tags[titleTemplateIdx].children,
      tags[titleIdx].children
    );
    if (newTitle !== null) {
      tags[titleIdx].children = newTitle || tags[titleIdx].children;
    } else {
      delete tags[titleIdx];
    }
  } else if (titleTemplateIdx !== -1) {
    const newTitle = renderTitleTemplate(
      tags[titleTemplateIdx].children
    );
    if (newTitle !== null) {
      tags[titleTemplateIdx].children = newTitle;
      tags[titleTemplateIdx].tag = "title";
    }
  }
  if (titleTemplateIdx !== -1) {
    delete tags[titleTemplateIdx];
  }
  return tags.filter(Boolean);
}
var DedupesTagsPlugin = (options) => {
  options = options || {};
  const dedupeKeys = options.dedupeKeys || ["hid", "vmid", "key"];
  return defineHeadPlugin({
    hooks: {
      "tag:normalise": function({ tag }) {
        dedupeKeys.forEach((key) => {
          if (tag.props[key]) {
            tag.key = tag.props[key];
            delete tag.props[key];
          }
        });
        const dedupe = tag.key ? `${tag.tag}:${tag.key}` : tagDedupeKey(tag);
        if (dedupe)
          tag._d = dedupe;
      },
      "tags:resolve": function(ctx) {
        const deduping = {};
        ctx.tags.forEach((tag) => {
          let dedupeKey = tag._d || tag._p;
          const dupedTag = deduping[dedupeKey];
          if (dupedTag) {
            let strategy = tag == null ? void 0 : tag.tagDuplicateStrategy;
            if (!strategy && (tag.tag === "htmlAttrs" || tag.tag === "bodyAttrs"))
              strategy = "merge";
            if (strategy === "merge") {
              const oldProps = dupedTag.props;
              ["class", "style"].forEach((key) => {
                if (tag.props[key] && oldProps[key]) {
                  if (key === "style" && !oldProps[key].endsWith(";"))
                    oldProps[key] += ";";
                  tag.props[key] = `${oldProps[key]} ${tag.props[key]}`;
                }
              });
              deduping[dedupeKey].props = {
                ...oldProps,
                ...tag.props
              };
              return;
            } else if (tag._e === dupedTag._e) {
              dedupeKey = tag._d = `${dedupeKey}:${tag._p}`;
            }
            const propCount = Object.keys(tag.props).length;
            if ((propCount === 0 || propCount === 1 && typeof tag.props["data-h-key"] !== "undefined") && !tag.children) {
              delete deduping[dedupeKey];
              return;
            }
          }
          deduping[dedupeKey] = tag;
        });
        ctx.tags = Object.values(deduping);
      }
    }
  });
};
var SortTagsPlugin = () => {
  return defineHeadPlugin({
    hooks: {
      "tags:resolve": (ctx) => {
        const tagIndexForKey = (key) => {
          var _a;
          return (_a = ctx.tags.find((tag) => tag._d === key)) == null ? void 0 : _a._p;
        };
        for (const tag of ctx.tags) {
          if (!tag.tagPriority || typeof tag.tagPriority === "number")
            continue;
          const modifiers = [{ prefix: "before:", offset: -1 }, { prefix: "after:", offset: 1 }];
          for (const { prefix, offset } of modifiers) {
            if (tag.tagPriority.startsWith(prefix)) {
              const key = tag.tagPriority.replace(prefix, "");
              const index = tagIndexForKey(key);
              if (typeof index !== "undefined")
                tag._p = index + offset;
            }
          }
        }
        ctx.tags.sort((a, b) => a._p - b._p).sort(sortTags);
      }
    }
  });
};
var TitleTemplatePlugin = () => {
  return defineHeadPlugin({
    hooks: {
      "tags:resolve": (ctx) => {
        ctx.tags = resolveTitleTemplateFromTags(ctx.tags);
      }
    }
  });
};
var DeprecatedTagAttrPlugin = () => {
  return defineHeadPlugin({
    hooks: {
      "tag:normalise": function({ tag }) {
        if (typeof tag.props.body !== "undefined") {
          tag.tagPosition = "bodyClose";
          delete tag.props.body;
        }
      }
    }
  });
};
var IsBrowser = typeof window !== "undefined";
var ProvideTagHashPlugin = () => {
  return defineHeadPlugin({
    hooks: {
      "tag:normalise": (ctx) => {
        var _a, _b;
        const { tag, entry } = ctx;
        if (!HasElementTags.includes(tag.tag))
          return;
        const isBrowser = IsBrowser || ((_b = (_a = getActiveHead()) == null ? void 0 : _a.resolvedOptions) == null ? void 0 : _b.document);
        if (!isBrowser && entry._m === "server" && tag.key)
          tag.props["data-h-key"] = tag._d;
      }
    }
  });
};
var PatchDomOnEntryUpdatesPlugin = (options) => {
  return defineHeadPlugin({
    hooks: {
      "entries:updated": function(head) {
        if (typeof (options == null ? void 0 : options.document) === "undefined" && typeof window === "undefined")
          return;
        let delayFn = options == null ? void 0 : options.delayFn;
        if (!delayFn && typeof requestAnimationFrame !== "undefined")
          delayFn = requestAnimationFrame;
        import("./dist-2G6FX7MF.js").then(({ debouncedRenderDOMHead: debouncedRenderDOMHead2 }) => {
          debouncedRenderDOMHead2(head, { document: (options == null ? void 0 : options.document) || window.document, delayFn });
        });
      }
    }
  });
};
var EventHandlersPlugin = () => {
  const stripEventHandlers = (tag) => {
    const props = {};
    const eventHandlers = {};
    Object.entries(tag.props).forEach(([key, value]) => {
      if (key.startsWith("on") && typeof value === "function")
        eventHandlers[key] = value;
      else
        props[key] = value;
    });
    return { props, eventHandlers };
  };
  return defineHeadPlugin({
    hooks: {
      "ssr:render": function(ctx) {
        ctx.tags = ctx.tags.map((tag) => {
          tag.props = stripEventHandlers(tag).props;
          return tag;
        });
      },
      "dom:beforeRenderTag": function(ctx) {
        const { props, eventHandlers } = stripEventHandlers(ctx.tag);
        if (!Object.keys(eventHandlers).length)
          return;
        ctx.tag.props = props;
        ctx.tag._eventHandlers = eventHandlers;
      },
      "dom:renderTag": function(ctx) {
        const $el = ctx.$el;
        if (!ctx.tag._eventHandlers || !$el)
          return;
        Object.entries(ctx.tag._eventHandlers).forEach(([k, value]) => {
          const sdeKey = `${ctx.tag._d || ctx.tag._p}:${k}`;
          const eventName = k.slice(2).toLowerCase();
          const handler = value;
          $el == null ? void 0 : $el.addEventListener(eventName, handler);
          ctx.entry._sde[sdeKey] = () => {
            $el.removeEventListener(eventName, handler);
          };
          delete ctx.queuedSideEffects[sdeKey];
        });
      }
    }
  });
};
function asArray(value) {
  return Array.isArray(value) ? value : [value];
}
var activeHead;
var setActiveHead = (head) => activeHead = head;
var getActiveHead = () => activeHead;
var TagEntityBits = 10;
function normaliseEntryTags(e) {
  return Object.entries(e.input).filter(([k, v]) => typeof v !== "undefined" && ValidHeadTags.includes(k)).map(
    ([k, value]) => asArray(value).map((props) => asArray(normaliseTag(k, props)))
  ).flat(3).map((t, i) => {
    t._e = e._i;
    t._p = (e._i << TagEntityBits) + i;
    return t;
  });
}
function createHead(options = {}) {
  let entries = [];
  let _sde = {};
  let _eid = 0;
  const hooks = createHooks();
  if (options == null ? void 0 : options.hooks)
    hooks.addHooks(options.hooks);
  options.plugins = [
    DeprecatedTagAttrPlugin(),
    DedupesTagsPlugin(),
    SortTagsPlugin(),
    TitleTemplatePlugin(),
    EventHandlersPlugin(),
    ProvideTagHashPlugin(),
    PatchDomOnEntryUpdatesPlugin({ document: options == null ? void 0 : options.document, delayFn: options == null ? void 0 : options.domDelayFn }),
    ...(options == null ? void 0 : options.plugins) || []
  ];
  options.plugins.forEach((p) => p.hooks && hooks.addHooks(p.hooks));
  const triggerUpdateHook = () => hooks.callHook("entries:updated", head);
  const head = {
    resolvedOptions: options,
    _popSideEffectQueue() {
      const sde = { ..._sde };
      _sde = {};
      return sde;
    },
    headEntries() {
      return entries;
    },
    get hooks() {
      return hooks;
    },
    push(input, options2) {
      const activeEntry = {
        _i: _eid++,
        input,
        _sde: {}
      };
      if (options2 == null ? void 0 : options2.mode)
        activeEntry._m = options2 == null ? void 0 : options2.mode;
      entries.push(activeEntry);
      triggerUpdateHook();
      const queueSideEffects = (e) => {
        _sde = { ..._sde, ...e._sde || {} };
        e._sde = {};
        triggerUpdateHook();
      };
      return {
        dispose() {
          entries = entries.filter((e) => {
            if (e._i !== activeEntry._i)
              return true;
            queueSideEffects(e);
            return false;
          });
        },
        patch(input2) {
          entries = entries.map((e) => {
            if (e._i === activeEntry._i) {
              queueSideEffects(e);
              activeEntry.input = e.input = input2;
              activeEntry._i = e._i = _eid++;
            }
            return e;
          });
        }
      };
    },
    async resolveTags() {
      const resolveCtx = { tags: [], entries: [...entries] };
      await hooks.callHook("entries:resolve", resolveCtx);
      for (const entry of resolveCtx.entries) {
        for (const tag of normaliseEntryTags(entry)) {
          const tagCtx = { tag, entry };
          await hooks.callHook("tag:normalise", tagCtx);
          resolveCtx.tags.push(tagCtx.tag);
        }
      }
      await hooks.callHook("tags:resolve", resolveCtx);
      return resolveCtx.tags;
    }
  };
  head.hooks.callHook("init", head);
  setActiveHead(head);
  return head;
}
function defineHeadPlugin(plugin) {
  return plugin;
}

// node_modules/.pnpm/@unhead+vue@0.5.1_typescript@5.2.2_vue@3.3.4/node_modules/@unhead/vue/dist/index.mjs
function resolveUnrefHeadInput(ref2) {
  const root = resolveUnref(ref2);
  if (!ref2 || !root)
    return root;
  if (Array.isArray(root))
    return root.map(resolveUnrefHeadInput);
  if (typeof root === "object") {
    return Object.fromEntries(
      Object.entries(root).map(([key, value]) => {
        if (key === "titleTemplate" || key.startsWith("on"))
          return [key, unref(value)];
        return [key, resolveUnrefHeadInput(value)];
      })
    );
  }
  return root;
}
var Vue3 = version.startsWith("3");
var IsBrowser2 = typeof window !== "undefined";
var headSymbol = "usehead";
function injectHead() {
  return getCurrentInstance() && inject(headSymbol) || getActiveHead();
}
function createHead2(options = {}) {
  const plugins = [
    VueReactiveUseHeadPlugin(),
    ...(options == null ? void 0 : options.plugins) || []
  ];
  const head = createHead({
    ...options,
    domDelayFn: (fn) => setTimeout(() => nextTick(() => fn()), 10),
    plugins
  });
  head.install = (app) => {
    if (Vue3) {
      app.config.globalProperties.$unhead = head;
      app.provide(headSymbol, head);
    }
  };
  return head;
}
var VueHeadMixin = {
  created() {
    const instance = getCurrentInstance();
    if (!instance)
      return;
    const options = instance.type;
    if (!options || !("head" in options))
      return;
    const source = typeof options.head === "function" ? () => options.head() : options.head;
    useHead(source);
  }
};
var VueReactiveUseHeadPlugin = () => {
  return defineHeadPlugin({
    hooks: {
      "entries:resolve": function(ctx) {
        for (const entry of ctx.entries)
          entry.input = resolveUnrefHeadInput(entry.input);
      }
    }
  });
};
var Vue2ProvideUnheadPlugin = function(_Vue, head) {
  _Vue.mixin({
    beforeCreate() {
      const options = this.$options;
      const origProvide = options.provide;
      options.provide = function() {
        let origProvideResult;
        if (typeof origProvide === "function")
          origProvideResult = origProvide.call(this);
        else
          origProvideResult = origProvide || {};
        return {
          ...origProvideResult,
          [headSymbol]: head
        };
      };
    }
  });
};
function clientUseHead(input, options = {}) {
  const head = injectHead();
  const vm = getCurrentInstance();
  if (!vm) {
    head.push(input, options);
    return;
  }
  const resolvedInput = ref({});
  watchEffect(() => {
    resolvedInput.value = resolveUnrefHeadInput(input);
  });
  let entry;
  watch(resolvedInput, (e) => {
    if (!entry)
      entry = head.push(e, options);
    else
      entry.patch(e);
  }, { immediate: true });
  onBeforeUnmount(() => {
    entry == null ? void 0 : entry.dispose();
  });
}
function serverUseHead(input, options = {}) {
  const head = injectHead();
  head.push(input, options);
}
function useServerHead(input, options = {}) {
  useHead(input, { ...options, mode: "server" });
}
function useHead(input, options = {}) {
  var _a;
  const head = injectHead();
  const isBrowser = IsBrowser2 || ((_a = head.resolvedOptions) == null ? void 0 : _a.document);
  if (options.mode === "server" && isBrowser || options.mode === "client" && !isBrowser)
    return;
  IsBrowser2 ? clientUseHead(input, options) : serverUseHead(input, options);
}

// node_modules/.pnpm/@unhead+ssr@0.5.1/node_modules/@unhead/ssr/dist/index.mjs
var SelfClosingTags = ["meta", "link", "base"];
var propsToString = (props) => {
  const handledAttributes = [];
  for (const [key, value] of Object.entries(props)) {
    if (value === false || value == null)
      continue;
    let attribute = key;
    if (value !== true)
      attribute += `="${String(value).replace(/"/g, "&quot;")}"`;
    handledAttributes.push(attribute);
  }
  return handledAttributes.length > 0 ? ` ${handledAttributes.join(" ")}` : "";
};
var tagToString = (tag) => {
  const attrs = propsToString(tag.props);
  const openTag = `<${tag.tag}${attrs}>`;
  return SelfClosingTags.includes(tag.tag) ? openTag : `${openTag}${tag.children || ""}</${tag.tag}>`;
};
function ssrRenderTags(tags) {
  const schema = { htmlAttrs: {}, bodyAttrs: {}, tags: { head: [], bodyClose: [], bodyOpen: [] } };
  for (const tag of tags) {
    if (tag.tag === "htmlAttrs" || tag.tag === "bodyAttrs") {
      schema[tag.tag] = { ...schema[tag.tag], ...tag.props };
      continue;
    }
    schema.tags[tag.tagPosition || "head"].push(tagToString(tag));
  }
  return {
    headTags: schema.tags.head.join("\n"),
    bodyTags: schema.tags.bodyClose.join("\n"),
    bodyTagsOpen: schema.tags.bodyOpen.join("\n"),
    htmlAttrs: propsToString(schema.htmlAttrs),
    bodyAttrs: propsToString(schema.bodyAttrs)
  };
}
async function renderSSRHead(head) {
  const beforeRenderCtx = { shouldRender: true };
  await head.hooks.callHook("ssr:beforeRender", beforeRenderCtx);
  if (!beforeRenderCtx.shouldRender) {
    return {
      headTags: "",
      bodyTags: "",
      bodyTagsOpen: "",
      htmlAttrs: "",
      bodyAttrs: ""
    };
  }
  const ctx = { tags: await head.resolveTags() };
  await head.hooks.callHook("ssr:render", ctx);
  const html = ssrRenderTags(ctx.tags);
  const renderCtx = { tags: ctx.tags, html };
  await head.hooks.callHook("ssr:rendered", renderCtx);
  return renderCtx.html;
}

// node_modules/.pnpm/@vueuse+head@1.0.0_typescript@5.2.2_vue@3.3.4/node_modules/@vueuse/head/dist/index.mjs
function createHead3(initHeadObject) {
  const head = createHead2();
  const legacyHead = {
    headTags() {
      return head.resolveTags();
    },
    addHeadObjs(input, options) {
      return head.push(input, options);
    },
    updateDOM(document2, force) {
      if (force)
        renderDOMHead(head, { document: document2 });
      else
        debouncedRenderDOMHead(head, { delayFn: (fn) => setTimeout(() => fn(), 50), document: document2 });
    }
  };
  head.headTags = legacyHead.headTags;
  head.addHeadObjs = legacyHead.addHeadObjs;
  head.updateDOM = legacyHead.updateDOM;
  if (initHeadObject)
    head.push(initHeadObject);
  return head;
}
var HeadVuePlugin = Vue2ProvideUnheadPlugin;
var renderHeadToString = (head) => renderSSRHead(head);
var Vue2 = version.startsWith("2.");
var IsBrowser3 = typeof window !== "undefined";
var addVNodeToHeadObj = (node, obj) => {
  const nodeType = Vue2 ? node.tag : node.type;
  const type = nodeType === "html" ? "htmlAttrs" : nodeType === "body" ? "bodyAttrs" : nodeType;
  if (typeof type !== "string" || !(type in obj))
    return;
  const nodeData = Vue2 ? node.data : node;
  const props = (Vue2 ? nodeData.attrs : node.props) || {};
  if (Vue2) {
    if (nodeData.staticClass)
      props.class = nodeData.staticClass;
    if (nodeData.staticStyle)
      props.style = Object.entries(nodeData.staticStyle).map(([key, value]) => `${key}:${value}`).join(";");
  }
  if (node.children) {
    const childrenAttr = Vue2 ? "text" : "children";
    props.children = Array.isArray(node.children) ? node.children[0][childrenAttr] : node[childrenAttr];
  }
  if (Array.isArray(obj[type]))
    obj[type].push(props);
  else if (type === "title")
    obj.title = props.children;
  else
    obj[type] = props;
};
var vnodesToHeadObj = (nodes) => {
  const obj = {
    title: void 0,
    htmlAttrs: void 0,
    bodyAttrs: void 0,
    base: void 0,
    meta: [],
    link: [],
    style: [],
    script: [],
    noscript: []
  };
  for (const node of nodes) {
    if (typeof node.type === "symbol" && Array.isArray(node.children)) {
      for (const childNode of node.children)
        addVNodeToHeadObj(childNode, obj);
    } else {
      addVNodeToHeadObj(node, obj);
    }
  }
  return obj;
};
var Head = defineComponent({
  name: "Head",
  setup(_, { slots }) {
    const head = injectHead();
    const obj = ref({});
    const entry = head.push(obj);
    if (IsBrowser3) {
      onBeforeUnmount(() => {
        entry.dispose();
      });
    }
    return () => {
      watchEffect(() => {
        if (!slots.default)
          return;
        entry.patch(vnodesToHeadObj(slots.default()));
      });
      return null;
    };
  }
});
export {
  Head,
  HeadVuePlugin,
  VueHeadMixin,
  createHead3 as createHead,
  renderHeadToString,
  useHead,
  useServerHead
};
//# sourceMappingURL=@vueuse_head.js.map
