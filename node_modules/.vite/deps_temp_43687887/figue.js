import {
  require_lodash
} from "./chunk-CHFOB7VC.js";
import {
  __toESM
} from "./chunk-2LSFTFF7.js";

// node_modules/.pnpm/figue@1.2.0/node_modules/figue/dist/index.mjs
var import_lodash = __toESM(require_lodash(), 1);
var format$7 = {
  validate: (value) => import_lodash.default.isNumber(value) && !import_lodash.default.isNaN(value) && import_lodash.default.isFinite(value),
  coerce: (value) => import_lodash.default.isString(value) ? parseFloat(value) : value
};
var format$6 = {
  validate: (value) => import_lodash.default.isInteger(value),
  coerce: (value) => import_lodash.default.isString(value) ? parseInt(value) : value
};
var format$5 = {
  validate: (value, { values }) => import_lodash.default.isString(value) && values.includes(value),
  coerce: (value) => value.toString()
};
var format$4 = {
  validate: () => true,
  coerce: (value) => value
};
var format$3 = {
  validate: (value) => import_lodash.default.isString(value),
  coerce: (value) => value.toString()
};
var format$2 = {
  validate: () => true,
  coerce: (value) => import_lodash.default.isString(value) ? value.trim().toLowerCase() === "true" : Boolean(value)
};
var format$1 = {
  validate: (value, { validate }) => (validate == null ? void 0 : validate(value)) ?? true,
  coerce: (value, { coerce }) => (coerce == null ? void 0 : coerce(value)) ?? value
};
var format = {
  validate: (value) => import_lodash.default.isArray(value) && value.every((item) => import_lodash.default.isString(item)),
  coerce: (value) => {
    if (!import_lodash.default.isString(value))
      return value;
    if (value === "")
      return [];
    return value.split(",");
  }
};
var formats = {
  integer: format$6,
  enum: format$5,
  float: format$7,
  any: format$4,
  string: format$3,
  boolean: format$2,
  custom: format$1,
  array: format
};
var isFalsyOrHasThrown = (cb) => {
  try {
    return !cb();
  } catch (e) {
    return true;
  }
};
function flattenSchema(schema, keys = []) {
  const acc = [];
  for (const [key, value] of Object.entries(schema)) {
    const valueHasFormat = Object.entries(value).some(([k, v]) => k === "format" && import_lodash.default.isString(v));
    const path = [...keys, key];
    if (import_lodash.default.isObject(value) && !valueHasFormat) {
      const childAcc = flattenSchema(value, path);
      acc.push(...childAcc);
    } else {
      acc.push({
        path,
        schema: value
      });
    }
  }
  return acc;
}
var Figue = class {
  constructor(schema) {
    this.schema = schema;
    this.env = {};
    this.schemaFlat = flattenSchema(schema);
  }
  loadEnv(env) {
    this.env = import_lodash.default.merge(this.env, env);
    return this;
  }
  loadConfig(config) {
    this.config = import_lodash.default.merge(this.config, config);
    return this;
  }
  validate() {
    const configValues = this.getConfig();
    const errors = [];
    for (const { path, schema } of this.schemaFlat) {
      const { format: format2 } = schema;
      const { validate } = formats[format2] ?? {};
      if (!validate) {
        throw new Error(`[figue:invalid-format] The format '${format2}' does not exist, valid formats are ${Object.keys(formats).join(", ")}.`);
      }
      const value = import_lodash.default.get(configValues, path);
      if (isFalsyOrHasThrown(() => validate(value, schema))) {
        errors.push(`[figue:validation-error] The key '${path}' does not comply with the format '${format2}', received value ${JSON.stringify(value)}`);
      }
    }
    if (errors.length > 0) {
      throw new TypeError(errors.join("\n"));
    }
    return this;
  }
  getValue({ path, schema }) {
    const { coerce } = formats[schema.format] ?? {};
    if (!coerce) {
      throw new Error(`[figue:invalid-format] The format '${schema.format}' does not exist, valid formats are ${Object.keys(formats).join(", ")}.`);
    }
    const value = this.env[schema.env] ?? import_lodash.default.get(this.config, path) ?? schema.default;
    return (coerce == null ? void 0 : coerce(value, schema)) ?? value;
  }
  getConfig() {
    const config = this.schemaFlat.reduce((acc, { path, schema }) => {
      const value = this.getValue({ path, schema });
      import_lodash.default.set(acc, path, value);
      return acc;
    }, {});
    return config;
  }
};
var figue = (schema) => new Figue(schema);
export {
  Figue,
  figue
};
//# sourceMappingURL=figue.js.map
