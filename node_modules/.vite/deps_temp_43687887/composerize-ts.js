import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-2LSFTFF7.js";

// node_modules/.pnpm/flex-js@1.0.5/node_modules/flex-js/src/Lexer.js
var require_Lexer = __commonJS({
  "node_modules/.pnpm/flex-js@1.0.5/node_modules/flex-js/src/Lexer.js"(exports, module) {
    function Lexer2() {
      this.isNode = typeof window === "undefined";
      this.idRegExp = /[a-z_][a-z0-9_-]*/i;
      this.clear();
    }
    Lexer2.EOF = 0;
    Lexer2.STATE_INITIAL = "INITIAL";
    Lexer2.STATE_ANY = "*";
    Lexer2.RULE_EOF = "<<EOF>>";
    Lexer2.prototype.reset = function() {
      this.source = "";
      this.index = 0;
      this.text = void 0;
      this.state = Lexer2.STATE_INITIAL;
      this.ruleIndex = void 0;
      this.readMore = false;
      this.stateStack = [];
      this.rejectedRules = [];
    };
    Lexer2.prototype.clear = function() {
      this.states = {};
      this.definitions = [];
      this.rules = {};
      this.ignoreCase = false;
      this.debugEnabled = false;
      this.addState(Lexer2.STATE_INITIAL);
      this.reset();
    };
    Lexer2.prototype.setIgnoreCase = function(ignoreCase) {
      this.ignoreCase = ignoreCase;
    };
    Lexer2.prototype.setDebugEnabled = function(debugEnabled) {
      this.debugEnabled = debugEnabled;
    };
    Lexer2.prototype.addState = function(name, exclusive) {
      this.states[name] = { name, exclusive: !!exclusive };
    };
    Lexer2.prototype.addDefinition = function(name, expression) {
      if (typeof name !== "string" || !this.idRegExp.test(name)) {
        throw new Error('Invalid definition name "' + name + '"');
      }
      if (typeof expression === "string") {
        if (expression.length === 0) {
          throw new Error('Empty expression for definition "' + name + '"');
        }
        expression = this.escapeRegExp(expression);
      } else if (expression instanceof RegExp) {
        if (expression.source === "(?:)") {
          throw new Error('Empty expression for definition "' + name + '"');
        }
        if (expression.flags !== "") {
          throw new Error("Expression flags are not supported for definition expressions");
        }
        expression = expression.source;
      } else {
        throw new Error('Invalid expression for definition "' + name + '"');
      }
      this.definitions[name] = expression;
    };
    Lexer2.prototype.addStateRule = function(states, expression, action) {
      if (states === void 0 || states === null) {
        states = [];
        for (var index in this.states) {
          var state = this.states[index];
          if (!state.exclusive) {
            states.push(state.name);
          }
        }
      } else if (states === Lexer2.STATE_ANY) {
        states = [];
        for (var index in this.states) {
          var state = this.states[index];
          states.push(state.name);
        }
      } else if (typeof states === "string") {
        states = [states];
      }
      states = states.filter(function(state2) {
        return !!state2;
      });
      if (!states.length) {
        throw new Error("Unable to add rule to empty list of states");
      }
      var notRegisteredStates = states.reduce((function(acc, state2) {
        if (!this.states[state2]) {
          acc.push(state2);
        }
        return acc;
      }).bind(this), []);
      if (notRegisteredStates.length) {
        throw new Error("Unable to register rule within unregistered state(s): " + notRegisteredStates.join(", "));
      }
      var source;
      var flags;
      var fixedWidth;
      if (expression === Lexer2.RULE_EOF) {
        source = null;
      } else if (typeof expression === "string") {
        if (expression.length === 0) {
          throw new Error('Empty expression for rule used in states "' + states.join(", ") + '"');
        }
        source = this.escapeRegExp(expression);
        fixedWidth = expression.length;
        flags = "";
      } else if (expression instanceof RegExp) {
        if (expression.source === "(?:)") {
          throw new Error('Empty expression for rule used in states "' + states.join(", ") + '"');
        }
        if (expression.flags !== "") {
          var notSupportedFlags = expression.flags.split("").filter(function(flag) {
            return flag !== "i" && flag !== "u";
          });
          if (notSupportedFlags.length) {
            throw new Error('Expression flags besides "i" and "u" are not supported');
          }
        }
        source = expression.source;
        flags = expression.flags;
      } else {
        throw new Error('Invalid rule expression "' + expression + '"');
      }
      if (action && typeof action !== "function") {
        throw new Error("Invalid rule action: should be function or empty");
      }
      var compiledExpression = source === null ? null : this.compileRuleExpression(source, flags);
      var hasBOL = compiledExpression === null ? null : this.isRegExpMatchBOL(compiledExpression);
      var hasEOL = compiledExpression === null ? null : this.isRegExpMatchEOL(compiledExpression);
      var isEOF = source === null;
      var rule = {
        expression: compiledExpression,
        hasBOL,
        hasEOL,
        isEOF,
        action,
        fixedWidth
        // used for weighted match optmization
      };
      for (var index in states) {
        var state = states[index];
        if (!this.rules[state]) {
          this.rules[state] = [];
        }
        this.rules[state].push(rule);
      }
    };
    Lexer2.prototype.addStateRules = function(states, rules) {
      for (var index in rules) {
        var rule = rules[index];
        this.addStateRule(states, rule.expression, rule.action);
      }
    };
    Lexer2.prototype.addRule = function(expression, action) {
      this.addStateRule(void 0, expression, action);
    };
    Lexer2.prototype.addRules = function(rules) {
      this.addStateRules(void 0, rules);
    };
    Lexer2.prototype.setSource = function(source) {
      this.source = source;
      this.index = 0;
    };
    Lexer2.prototype.lex = function() {
      var result;
      do {
        result = this.scan();
      } while (result === void 0 && result !== Lexer2.EOF);
      return result;
    };
    Lexer2.prototype.lexAll = function() {
      var result = [];
      var token;
      while ((token = this.lex()) !== Lexer2.EOF) {
        result.push(token);
      }
      return result;
    };
    Lexer2.prototype.discard = function() {
      return void 0;
    };
    Lexer2.prototype.echo = function() {
      if (this.isNode) {
        process.stdout.write(this.text);
      } else {
        console.log(this.text);
      }
    };
    Lexer2.prototype.begin = function(newState) {
      if (newState === void 0) {
        newState = Lexer2.STATE_INITIAL;
      }
      if (!this.states[newState]) {
        throw new Error('State "' + newState + '" is not registered');
      }
      this.state = newState;
    };
    Lexer2.prototype.reject = function() {
      this.index -= this.text.length;
      this.rejectedRules.push(this.ruleIndex);
    };
    Lexer2.prototype.more = function() {
      this.readMore = true;
    };
    Lexer2.prototype.less = function(n) {
      if (n > this.text.length) {
        return;
      }
      this.index -= this.text.length - n;
      this.text = this.text.substr(0, n);
    };
    Lexer2.prototype.unput = function(s) {
      this.source = this.source.substr(0, this.index) + s + this.source.substr(this.index);
    };
    Lexer2.prototype.input = function(n) {
      var value = this.source.substr(this.index, n === void 0 ? 1 : n);
      this.index += value.length;
      return value;
    };
    Lexer2.prototype.terminate = function() {
      this.reset();
      return Lexer2.EOF;
    };
    Lexer2.prototype.restart = function(newSource) {
      if (newSource !== void 0) {
        this.source = newSource;
      }
      this.index = 0;
    };
    Lexer2.prototype.pushState = function(newState) {
      if (!this.states[newState]) {
        throw new Error('State "' + newState + '" is not registered');
      }
      this.stateStack.push(this.state);
      this.begin(newState);
    };
    Lexer2.prototype.topState = function() {
      if (!this.stateStack.length) {
        return void 0;
      }
      return this.stateStack[this.stateStack.length - 1];
    };
    Lexer2.prototype.popState = function() {
      if (!this.stateStack.length) {
        throw new Error("Unable to pop state");
      }
      var oldState = this.stateStack.pop();
      this.begin(oldState);
    };
    Lexer2.prototype.switchState = function(newState) {
      this.begin(newState);
    };
    Lexer2.prototype.scan = function() {
      var isEOF = this.index >= this.source.length;
      var matchedRule;
      var matchedIndex;
      var matchedValue = "";
      var matchedValueLength = 0;
      var rules = this.rules[this.state] || [];
      for (var index in rules) {
        if (this.rejectedRules.indexOf(index) !== -1) {
          continue;
        }
        var rule = rules[index];
        if (isEOF) {
          if (rule.isEOF) {
            matchedRule = rule;
            matchedIndex = index;
            matchedValue = "";
            break;
          }
        } else {
          if (rule.fixedWidth === void 0 || rule.fixedWidth > matchedValueLength) {
            var curMatch = this.execRegExp(rule.expression);
            if (curMatch !== void 0) {
              var curMatchLength = curMatch.length;
              if (rule.hasBOL) {
                curMatchLength++;
              }
              if (rule.hasEOL) {
                curMatchLength++;
              }
              if (curMatchLength > matchedValueLength) {
                matchedRule = rule;
                matchedIndex = index;
                matchedValue = curMatch;
                matchedValueLength = curMatchLength;
              }
            }
          }
        }
      }
      if (matchedRule && this.debugEnabled) {
        this.logAccept(this.state, matchedRule.expression, matchedValue);
      }
      this.ruleIndex = matchedIndex;
      this.text = this.readMore ? this.text : "";
      this.readMore = false;
      if (!matchedRule) {
        if (!isEOF) {
          this.text += this.source.charAt(this.index);
          this.index++;
          return this.echo();
        } else {
          this.text = "";
          return this.terminate();
        }
      }
      this.text += matchedValue;
      this.index += this.text.length;
      var rejectedBefore = this.rejectedRules.length;
      var actionResult = matchedRule.action ? matchedRule.action(this) : this.discard();
      var hasRejection = this.rejectedRules.length > rejectedBefore;
      if (hasRejection) {
        return;
      }
      this.rejectedRules = [];
      if (isEOF) {
        isEOF = this.index >= this.source.length;
      }
      return isEOF ? this.terminate() : actionResult;
    };
    Lexer2.prototype.logAccept = function(state, expression, value) {
      console.log(
        " - [" + state + "] accepting rule /" + this.encodeString(expression.source) + '/ ("' + this.encodeString(value) + '")'
      );
    };
    Lexer2.prototype.encodeString = function(s) {
      return s.replace(/\r/g, "\\r").replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\f/g, "\\f").replace(/\0/g, "\\0");
    };
    Lexer2.prototype.execRegExp = function(re) {
      re.lastIndex = this.index;
      var result = re.exec(this.source);
      return result ? result[0] : void 0;
    };
    Lexer2.prototype.compileRuleExpression = function(source, flags) {
      for (var defName in this.definitions) {
        var defExpression = this.definitions[defName];
        var defNameRe = new RegExp("{" + defName + "}", "ig");
        source = source.replace(defNameRe, "(?:" + defExpression + ")");
      }
      if (this.ignoreCase && flags.indexOf("i") === -1) {
        flags += "i";
      }
      return new RegExp(source, flags + "ym");
    };
    Lexer2.prototype.escapeRegExp = function(s) {
      return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    };
    Lexer2.prototype.isRegExpMatchBOL = function(re) {
      return re.source.substr(0, 1) === "^";
    };
    Lexer2.prototype.isRegExpMatchEOL = function(re) {
      return re.source.substr(-1) === "$";
    };
    module.exports = Lexer2;
  }
});

// node_modules/.pnpm/flex-js@1.0.5/node_modules/flex-js/index.js
var require_flex_js = __commonJS({
  "node_modules/.pnpm/flex-js@1.0.5/node_modules/flex-js/index.js"(exports, module) {
    module.exports = require_Lexer();
  }
});

// node_modules/.pnpm/is-primitive@3.0.1/node_modules/is-primitive/index.js
var require_is_primitive = __commonJS({
  "node_modules/.pnpm/is-primitive@3.0.1/node_modules/is-primitive/index.js"(exports, module) {
    "use strict";
    module.exports = function isPrimitive(val) {
      if (typeof val === "object") {
        return val === null;
      }
      return typeof val !== "function";
    };
  }
});

// node_modules/.pnpm/isobject@3.0.1/node_modules/isobject/index.js
var require_isobject = __commonJS({
  "node_modules/.pnpm/isobject@3.0.1/node_modules/isobject/index.js"(exports, module) {
    "use strict";
    module.exports = function isObject(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    };
  }
});

// node_modules/.pnpm/is-plain-object@2.0.4/node_modules/is-plain-object/index.js
var require_is_plain_object = __commonJS({
  "node_modules/.pnpm/is-plain-object@2.0.4/node_modules/is-plain-object/index.js"(exports, module) {
    "use strict";
    var isObject = require_isobject();
    function isObjectObject(o) {
      return isObject(o) === true && Object.prototype.toString.call(o) === "[object Object]";
    }
    module.exports = function isPlainObject(o) {
      var ctor, prot;
      if (isObjectObject(o) === false)
        return false;
      ctor = o.constructor;
      if (typeof ctor !== "function")
        return false;
      prot = ctor.prototype;
      if (isObjectObject(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/.pnpm/set-value@4.1.0/node_modules/set-value/index.js
var require_set_value = __commonJS({
  "node_modules/.pnpm/set-value@4.1.0/node_modules/set-value/index.js"(exports, module) {
    "use strict";
    var { deleteProperty } = Reflect;
    var isPrimitive = require_is_primitive();
    var isPlainObject = require_is_plain_object();
    var isObject = (value) => {
      return typeof value === "object" && value !== null || typeof value === "function";
    };
    var isUnsafeKey = (key) => {
      return key === "__proto__" || key === "constructor" || key === "prototype";
    };
    var validateKey = (key) => {
      if (!isPrimitive(key)) {
        throw new TypeError("Object keys must be strings or symbols");
      }
      if (isUnsafeKey(key)) {
        throw new Error(`Cannot set unsafe key: "${key}"`);
      }
    };
    var toStringKey = (input) => {
      return Array.isArray(input) ? input.flat().map(String).join(",") : input;
    };
    var createMemoKey = (input, options) => {
      if (typeof input !== "string" || !options)
        return input;
      let key = input + ";";
      if (options.arrays !== void 0)
        key += `arrays=${options.arrays};`;
      if (options.separator !== void 0)
        key += `separator=${options.separator};`;
      if (options.split !== void 0)
        key += `split=${options.split};`;
      if (options.merge !== void 0)
        key += `merge=${options.merge};`;
      if (options.preservePaths !== void 0)
        key += `preservePaths=${options.preservePaths};`;
      return key;
    };
    var memoize = (input, options, fn) => {
      const key = toStringKey(options ? createMemoKey(input, options) : input);
      validateKey(key);
      const value = setValue.cache.get(key) || fn();
      setValue.cache.set(key, value);
      return value;
    };
    var splitString = (input, options = {}) => {
      const sep = options.separator || ".";
      const preserve = sep === "/" ? false : options.preservePaths;
      if (typeof input === "string" && preserve !== false && /\//.test(input)) {
        return [input];
      }
      const parts = [];
      let part = "";
      const push = (part2) => {
        let number;
        if (part2.trim() !== "" && Number.isInteger(number = Number(part2))) {
          parts.push(number);
        } else {
          parts.push(part2);
        }
      };
      for (let i = 0; i < input.length; i++) {
        const value = input[i];
        if (value === "\\") {
          part += input[++i];
          continue;
        }
        if (value === sep) {
          push(part);
          part = "";
          continue;
        }
        part += value;
      }
      if (part) {
        push(part);
      }
      return parts;
    };
    var split = (input, options) => {
      if (options && typeof options.split === "function")
        return options.split(input);
      if (typeof input === "symbol")
        return [input];
      if (Array.isArray(input))
        return input;
      return memoize(input, options, () => splitString(input, options));
    };
    var assignProp = (obj, prop, value, options) => {
      validateKey(prop);
      if (value === void 0) {
        deleteProperty(obj, prop);
      } else if (options && options.merge) {
        const merge = options.merge === "function" ? options.merge : Object.assign;
        if (merge && isPlainObject(obj[prop]) && isPlainObject(value)) {
          obj[prop] = merge(obj[prop], value);
        } else {
          obj[prop] = value;
        }
      } else {
        obj[prop] = value;
      }
      return obj;
    };
    var setValue = (target, path, value, options) => {
      if (!path || !isObject(target))
        return target;
      const keys = split(path, options);
      let obj = target;
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const next = keys[i + 1];
        validateKey(key);
        if (next === void 0) {
          assignProp(obj, key, value, options);
          break;
        }
        if (typeof next === "number" && !Array.isArray(obj[key])) {
          obj = obj[key] = [];
          continue;
        }
        if (!isObject(obj[key])) {
          obj[key] = {};
        }
        obj = obj[key];
      }
      return target;
    };
    setValue.split = split;
    setValue.cache = /* @__PURE__ */ new Map();
    setValue.clear = () => {
      setValue.cache = /* @__PURE__ */ new Map();
    };
    module.exports = setValue;
  }
});

// node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isCorrect = exports.isInSubnet = void 0;
    function isInSubnet(address) {
      if (this.subnetMask < address.subnetMask) {
        return false;
      }
      if (this.mask(address.subnetMask) === address.mask()) {
        return true;
      }
      return false;
    }
    exports.isInSubnet = isInSubnet;
    function isCorrect(defaultBits) {
      return function() {
        if (this.addressMinusSuffix !== this.correctForm()) {
          return false;
        }
        if (this.subnetMask === defaultBits && !this.parsedSubnet) {
          return true;
        }
        return this.parsedSubnet === String(this.subnetMask);
      };
    }
    exports.isCorrect = isCorrect;
  }
});

// node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/v4/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/v4/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RE_SUBNET_STRING = exports.RE_ADDRESS = exports.GROUPS = exports.BITS = void 0;
    exports.BITS = 32;
    exports.GROUPS = 4;
    exports.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
    exports.RE_SUBNET_STRING = /\/\d{1,2}$/;
  }
});

// node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/address-error.js
var require_address_error = __commonJS({
  "node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/address-error.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AddressError = void 0;
    var AddressError = (
      /** @class */
      function(_super) {
        __extends2(AddressError2, _super);
        function AddressError2(message, parseMessage) {
          var _this2 = _super.call(this, message) || this;
          _this2.name = "AddressError";
          if (parseMessage !== null) {
            _this2.parseMessage = parseMessage;
          }
          return _this2;
        }
        return AddressError2;
      }(Error)
    );
    exports.AddressError = AddressError;
  }
});

// node_modules/.pnpm/jsbn@1.1.0/node_modules/jsbn/index.js
var require_jsbn = __commonJS({
  "node_modules/.pnpm/jsbn@1.1.0/node_modules/jsbn/index.js"(exports, module) {
    (function() {
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        if (a != null)
          if ("number" == typeof a)
            this.fromNumber(a, b, c);
          else if (b == null && "string" != typeof a)
            this.fromString(a, 256);
          else
            this.fromString(a, b);
      }
      function nbi() {
        return new BigInteger(null);
      }
      function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this[i++] + w[j] + c;
          c = Math.floor(v / 67108864);
          w[j++] = v & 67108863;
        }
        return c;
      }
      function am2(i, x, w, j, c, n) {
        var xl = x & 32767, xh = x >> 15;
        while (--n >= 0) {
          var l = this[i] & 32767;
          var h = this[i++] >> 15;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
          c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
          w[j++] = l & 1073741823;
        }
        return c;
      }
      function am3(i, x, w, j, c, n) {
        var xl = x & 16383, xh = x >> 14;
        while (--n >= 0) {
          var l = this[i] & 16383;
          var h = this[i++] >> 14;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 16383) << 14) + w[j] + c;
          c = (l >> 28) + (m >> 14) + xh * h;
          w[j++] = l & 268435455;
        }
        return c;
      }
      var inBrowser = typeof navigator !== "undefined";
      if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr, vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv)
        BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }
      function bnpCopyTo(r) {
        for (var i = this.t - 1; i >= 0; --i)
          r[i] = this[i];
        r.t = this.t;
        r.s = this.s;
      }
      function bnpFromInt(x) {
        this.t = 1;
        this.s = x < 0 ? -1 : 0;
        if (x > 0)
          this[0] = x;
        else if (x < -1)
          this[0] = x + this.DV;
        else
          this.t = 0;
      }
      function nbv(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }
      function bnpFromString(s, b) {
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 256)
          k = 8;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else {
          this.fromRadix(s, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while (--i >= 0) {
          var x = k == 8 ? s[i] & 255 : intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-")
              mi = true;
            continue;
          }
          mi = false;
          if (sh == 0)
            this[this.t++] = x;
          else if (sh + k > this.DB) {
            this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
            this[this.t++] = x >> this.DB - sh;
          } else
            this[this.t - 1] |= x << sh;
          sh += k;
          if (sh >= this.DB)
            sh -= this.DB;
        }
        if (k == 8 && (s[0] & 128) != 0) {
          this.s = -1;
          if (sh > 0)
            this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
        }
        this.clamp();
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c)
          --this.t;
      }
      function bnToString(b) {
        if (this.s < 0)
          return "-" + this.negate().toString(b);
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else
          return this.toRadix(b);
        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
        var p = this.DB - i * this.DB % k;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) > 0) {
            m = true;
            r = int2char(d);
          }
          while (i >= 0) {
            if (p < k) {
              d = (this[i] & (1 << p) - 1) << k - p;
              d |= this[--i] >> (p += this.DB - k);
            } else {
              d = this[i] >> (p -= k) & km;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if (d > 0)
              m = true;
            if (m)
              r += int2char(d);
          }
        }
        return m ? r : "0";
      }
      function bnNegate() {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(a) {
        var r = this.s - a.s;
        if (r != 0)
          return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0)
          return this.s < 0 ? -r : r;
        while (--i >= 0)
          if ((r = this[i] - a[i]) != 0)
            return r;
        return 0;
      }
      function nbits(x) {
        var r = 1, t2;
        if ((t2 = x >>> 16) != 0) {
          x = t2;
          r += 16;
        }
        if ((t2 = x >> 8) != 0) {
          x = t2;
          r += 8;
        }
        if ((t2 = x >> 4) != 0) {
          x = t2;
          r += 4;
        }
        if ((t2 = x >> 2) != 0) {
          x = t2;
          r += 2;
        }
        if ((t2 = x >> 1) != 0) {
          x = t2;
          r += 1;
        }
        return r;
      }
      function bnBitLength() {
        if (this.t <= 0)
          return 0;
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i)
          r[i + n] = this[i];
        for (i = n - 1; i >= 0; --i)
          r[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
      }
      function bnpDRShiftTo(n, r) {
        for (var i = n; i < this.t; ++i)
          r[i - n] = this[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
      }
      function bnpLShiftTo(n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
          r[i + ds + 1] = this[i] >> cbs | c;
          c = (this[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i)
          r[i] = 0;
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
      }
      function bnpRShiftTo(n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
          r[i - ds - 1] |= (this[i] & bm) << cbs;
          r[i - ds] = this[i] >> bs;
        }
        if (bs > 0)
          r[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
      }
      function bnpSubTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] - a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c -= a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c < -1)
          r[i++] = this.DV + c;
        else if (c > 0)
          r[i++] = c;
        r.t = i;
        r.clamp();
      }
      function bnpMultiplyTo(a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < y.t; ++i)
          r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
          var c = x.am(i, x[i], r, 2 * i, 0, 1);
          if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
          }
        }
        if (r.t > 0)
          r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
      }
      function bnpDivRemTo(m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0)
          return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q != null)
            q.fromInt(0);
          if (r != null)
            this.copyTo(r);
          return;
        }
        if (r == null)
          r = nbi();
        var y = nbi(), ts = this.s, ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r);
        } else {
          pm.copyTo(y);
          pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0)
          return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t2 = q == null ? nbi() : q;
        y.dlShiftTo(j, t2);
        if (r.compareTo(t2) >= 0) {
          r[r.t++] = 1;
          r.subTo(t2, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t2);
        t2.subTo(y, y);
        while (y.t < ys)
          y[y.t++] = 0;
        while (--j >= 0) {
          var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
          if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t2);
            r.subTo(t2, r);
            while (r[i] < --qd)
              r.subTo(t2, r);
          }
        }
        if (q != null) {
          r.drShiftTo(ys, q);
          if (ts != ms)
            BigInteger.ZERO.subTo(q, q);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0)
          r.rShiftTo(nsh, r);
        if (ts < 0)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          a.subTo(r, r);
        return r;
      }
      function Classic(m) {
        this.m = m;
      }
      function cConvert(x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0)
          return x.mod(this.m);
        else
          return x;
      }
      function cRevert(x) {
        return x;
      }
      function cReduce(x) {
        x.divRemTo(this.m, null, x);
      }
      function cMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      function cSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1)
          return 0;
        var x = this[0];
        if ((x & 1) == 0)
          return 0;
        var y = x & 3;
        y = y * (2 - (x & 15) * y) & 15;
        y = y * (2 - (x & 255) * y) & 255;
        y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
        y = y * (2 - x * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m.DB - 15) - 1;
        this.mt2 = 2 * m.t;
      }
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          this.m.subTo(r, r);
        return r;
      }
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      function montReduce(x) {
        while (x.t <= this.mt2)
          x[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
          var j = x[i] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
          j = i + this.m.t;
          x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
          while (x[j] >= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
          }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function montSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function montMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
      }
      function bnpExp(e, z2) {
        if (e > 4294967295 || e < 1)
          return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
          z2.sqrTo(r, r2);
          if ((e & 1 << i) > 0)
            z2.mulTo(r2, g, r);
          else {
            var t2 = r;
            r = r2;
            r2 = t2;
          }
        }
        return z2.revert(r);
      }
      function bnModPowInt(e, m) {
        var z2;
        if (e < 256 || m.isEven())
          z2 = new Classic(m);
        else
          z2 = new Montgomery(m);
        return this.exp(e, z2);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r = nbi();
        this.copyTo(r);
        return r;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1)
            return this[0] - this.DV;
          else if (this.t == 0)
            return -1;
        } else if (this.t == 1)
          return this[0];
        else if (this.t == 0)
          return 0;
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this[0] << 16 >> 16;
      }
      function bnpChunkSize(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
      }
      function bnSigNum() {
        if (this.s < 0)
          return -1;
        else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
          return 0;
        else
          return 1;
      }
      function bnpToRadix(b) {
        if (b == null)
          b = 10;
        if (this.signum() == 0 || b < 2 || b > 36)
          return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
        this.divRemTo(d, y, z2);
        while (y.signum() > 0) {
          r = (a + z2.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d, y, z2);
        }
        return z2.intValue().toString(b) + r;
      }
      function bnpFromRadix(s, b) {
        this.fromInt(0);
        if (b == null)
          b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
          var x = intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() == 0)
              mi = true;
            continue;
          }
          w = b * w + x;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpFromNumber(a, b, c) {
        if ("number" == typeof b) {
          if (a < 2)
            this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven())
              this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a)
                this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x = new Array(), t2 = a & 7;
          x.length = (a >> 3) + 1;
          b.nextBytes(x);
          if (t2 > 0)
            x[0] &= (1 << t2) - 1;
          else
            x[0] = 0;
          this.fromString(x, 256);
        }
      }
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - i * this.DB % 8, d, k = 0;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | this.s << this.DB - p;
          while (i >= 0) {
            if (p < 8) {
              d = (this[i] & (1 << p) - 1) << 8 - p;
              d |= this[--i] >> (p += this.DB - 8);
            } else {
              d = this[i] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if ((d & 128) != 0)
              d |= -256;
            if (k == 0 && (this.s & 128) != (d & 128))
              ++k;
            if (k > 0 || d != this.s)
              r[k++] = d;
          }
        }
        return r;
      }
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      function bnpBitwiseTo(a, op, r) {
        var i, f, m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i)
          r[i] = op(this[i], a[i]);
        if (a.t < this.t) {
          f = a.s & this.DM;
          for (i = m; i < this.t; ++i)
            r[i] = op(this[i], f);
          r.t = this.t;
        } else {
          f = this.s & this.DM;
          for (i = m; i < a.t; ++i)
            r[i] = op(f, a[i]);
          r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
      }
      function op_and(x, y) {
        return x & y;
      }
      function bnAnd(a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
      }
      function op_or(x, y) {
        return x | y;
      }
      function bnOr(a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
      }
      function op_xor(x, y) {
        return x ^ y;
      }
      function bnXor(a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
      }
      function op_andnot(x, y) {
        return x & ~y;
      }
      function bnAndNot(a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
      }
      function bnNot() {
        var r = nbi();
        for (var i = 0; i < this.t; ++i)
          r[i] = this.DM & ~this[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      function bnShiftLeft(n) {
        var r = nbi();
        if (n < 0)
          this.rShiftTo(-n, r);
        else
          this.lShiftTo(n, r);
        return r;
      }
      function bnShiftRight(n) {
        var r = nbi();
        if (n < 0)
          this.lShiftTo(-n, r);
        else
          this.rShiftTo(n, r);
        return r;
      }
      function lbit(x) {
        if (x == 0)
          return -1;
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0)
          ++r;
        return r;
      }
      function bnGetLowestSetBit() {
        for (var i = 0; i < this.t; ++i)
          if (this[i] != 0)
            return i * this.DB + lbit(this[i]);
        if (this.s < 0)
          return this.t * this.DB;
        return -1;
      }
      function cbit(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }
      function bnBitCount() {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i)
          r += cbit(this[i] ^ x);
        return r;
      }
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t)
          return this.s != 0;
        return (this[j] & 1 << n % this.DB) != 0;
      }
      function bnpChangeBit(n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
      }
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      function bnpAddTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] + a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c += a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c > 0)
          r[i++] = c;
        else if (c < -1)
          r[i++] = this.DV + c;
        r.t = i;
        r.clamp();
      }
      function bnAdd(a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
      }
      function bnSubtract(a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
      }
      function bnMultiply(a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
      }
      function bnSquare() {
        var r = nbi();
        this.squareTo(r);
        return r;
      }
      function bnDivide(a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
      }
      function bnRemainder(a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
      }
      function bnDivideAndRemainder(a) {
        var q = nbi(), r = nbi();
        this.divRemTo(a, q, r);
        return new Array(q, r);
      }
      function bnpDMultiply(n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(n, w) {
        if (n == 0)
          return;
        while (this.t <= w)
          this[this.t++] = 0;
        this[w] += n;
        while (this[w] >= this.DV) {
          this[w] -= this.DV;
          if (++w >= this.t)
            this[this.t++] = 0;
          ++this[w];
        }
      }
      function NullExp() {
      }
      function nNop(x) {
        return x;
      }
      function nMulTo(x, y, r) {
        x.multiplyTo(y, r);
      }
      function nSqrTo(x, r) {
        x.squareTo(r);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e) {
        return this.exp(e, new NullExp());
      }
      function bnpMultiplyLowerTo(a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0;
        r.t = i;
        while (i > 0)
          r[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i)
          r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i)
          this.am(0, a[i], r, i, 0, n - i);
        r.clamp();
      }
      function bnpMultiplyUpperTo(a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0;
        while (--i >= 0)
          r[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
          r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
      }
      function Barrett(m) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
      }
      function barrettConvert(x) {
        if (x.s < 0 || x.t > 2 * this.m.t)
          return x.mod(this.m);
        else if (x.compareTo(this.m) < 0)
          return x;
        else {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
      }
      function barrettRevert(x) {
        return x;
      }
      function barrettReduce(x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
          x.t = this.m.t + 1;
          x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0)
          x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function barrettSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function barrettMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e, m) {
        var i = e.bitLength(), k, r = nbv(1), z2;
        if (i <= 0)
          return r;
        else if (i < 18)
          k = 1;
        else if (i < 48)
          k = 3;
        else if (i < 144)
          k = 4;
        else if (i < 768)
          k = 5;
        else
          k = 6;
        if (i < 8)
          z2 = new Classic(m);
        else if (m.isEven())
          z2 = new Barrett(m);
        else
          z2 = new Montgomery(m);
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z2.convert(this);
        if (k > 1) {
          var g2 = nbi();
          z2.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z2.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
          if (i >= k1)
            w = e[j] >> i - k1 & km;
          else {
            w = (e[j] & (1 << i + 1) - 1) << k1 - i;
            if (j > 0)
              w |= e[j - 1] >> this.DB + i - k1;
          }
          n = k;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i -= n) < 0) {
            i += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r);
            is1 = false;
          } else {
            while (n > 1) {
              z2.sqrTo(r, r2);
              z2.sqrTo(r2, r);
              n -= 2;
            }
            if (n > 0)
              z2.sqrTo(r, r2);
            else {
              t2 = r;
              r = r2;
              r2 = t2;
            }
            z2.mulTo(r2, g[w], r);
          }
          while (j >= 0 && (e[j] & 1 << i) == 0) {
            z2.sqrTo(r, r2);
            t2 = r;
            r = r2;
            r2 = t2;
            if (--i < 0) {
              i = this.DB - 1;
              --j;
            }
          }
        }
        return z2.revert(r);
      }
      function bnGCD(a) {
        var x = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
          var t2 = x;
          x = y;
          y = t2;
        }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0)
          return x;
        if (i < g)
          g = i;
        if (g > 0) {
          x.rShiftTo(g, x);
          y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
          if ((i = x.getLowestSetBit()) > 0)
            x.rShiftTo(i, x);
          if ((i = y.getLowestSetBit()) > 0)
            y.rShiftTo(i, y);
          if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
          } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0)
          y.lShiftTo(g, y);
        return y;
      }
      function bnpModInt(n) {
        if (n <= 0)
          return 0;
        var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0)
            r = this[0] % n;
          else
            for (var i = this.t - 1; i >= 0; --i)
              r = (d * r + this[i]) % n;
        return r;
      }
      function bnModInverse(m) {
        var ac = m.isEven();
        if (this.isEven() && ac || m.signum() == 0)
          return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven())
              b.subTo(m, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven())
              d.subTo(m, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac)
              a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac)
              c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0)
          return BigInteger.ZERO;
        if (d.compareTo(m) >= 0)
          return d.subtract(m);
        if (d.signum() < 0)
          d.addTo(m, d);
        else
          return d;
        if (d.signum() < 0)
          return d.add(m);
        else
          return d;
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t2) {
        var i, x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
          for (i = 0; i < lowprimes.length; ++i)
            if (x[0] == lowprimes[i])
              return true;
          return false;
        }
        if (x.isEven())
          return false;
        i = 1;
        while (i < lowprimes.length) {
          var m = lowprimes[i], j = i + 1;
          while (j < lowprimes.length && m < lplim)
            m *= lowprimes[j++];
          m = x.modInt(m);
          while (i < j)
            if (m % lowprimes[i++] == 0)
              return false;
        }
        return x.millerRabin(t2);
      }
      function bnpMillerRabin(t2) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0)
          return false;
        var r = n1.shiftRight(k);
        t2 = t2 + 1 >> 1;
        if (t2 > lowprimes.length)
          t2 = lowprimes.length;
        var a = nbi();
        for (var i = 0; i < t2; ++i) {
          a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
          var y = a.modPow(r, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0)
                return false;
            }
            if (y.compareTo(n1) != 0)
              return false;
          }
        }
        return true;
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      BigInteger.prototype.square = bnSquare;
      BigInteger.prototype.Barrett = Barrett;
      var rng_state;
      var rng_pool;
      var rng_pptr;
      function rng_seed_int(x) {
        rng_pool[rng_pptr++] ^= x & 255;
        rng_pool[rng_pptr++] ^= x >> 8 & 255;
        rng_pool[rng_pptr++] ^= x >> 16 & 255;
        rng_pool[rng_pptr++] ^= x >> 24 & 255;
        if (rng_pptr >= rng_psize)
          rng_pptr -= rng_psize;
      }
      function rng_seed_time() {
        rng_seed_int((/* @__PURE__ */ new Date()).getTime());
      }
      if (rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        var t;
        if (typeof window !== "undefined" && window.crypto) {
          if (window.crypto.getRandomValues) {
            var ua = new Uint8Array(32);
            window.crypto.getRandomValues(ua);
            for (t = 0; t < 32; ++t)
              rng_pool[rng_pptr++] = ua[t];
          } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            var z = window.crypto.random(32);
            for (t = 0; t < z.length; ++t)
              rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
          }
        }
        while (rng_pptr < rng_psize) {
          t = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t >>> 8;
          rng_pool[rng_pptr++] = t & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
      }
      function rng_get_byte() {
        if (rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
            rng_pool[rng_pptr] = 0;
          rng_pptr = 0;
        }
        return rng_state.next();
      }
      function rng_get_bytes(ba) {
        var i;
        for (i = 0; i < ba.length; ++i)
          ba[i] = rng_get_byte();
      }
      function SecureRandom() {
      }
      SecureRandom.prototype.nextBytes = rng_get_bytes;
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      function ARC4init(key) {
        var i, j, t2;
        for (i = 0; i < 256; ++i)
          this.S[i] = i;
        j = 0;
        for (i = 0; i < 256; ++i) {
          j = j + this.S[i] + key[i % key.length] & 255;
          t2 = this.S[i];
          this.S[i] = this.S[j];
          this.S[j] = t2;
        }
        this.i = 0;
        this.j = 0;
      }
      function ARC4next() {
        var t2;
        this.i = this.i + 1 & 255;
        this.j = this.j + this.S[this.i] & 255;
        t2 = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t2;
        return this.S[t2 + this.S[this.i] & 255];
      }
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      function prng_newstate() {
        return new Arcfour();
      }
      var rng_psize = 256;
      if (typeof exports !== "undefined") {
        exports = module.exports = {
          default: BigInteger,
          BigInteger,
          SecureRandom
        };
      } else {
        this.jsbn = {
          BigInteger,
          SecureRandom
        };
      }
    }).call(exports);
  }
});

// node_modules/.pnpm/sprintf-js@1.1.2/node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/.pnpm/sprintf-js@1.1.2/node_modules/sprintf-js/src/sprintf.js"(exports) {
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign;
        for (i = 0; i < tree_length; i++) {
          if (typeof parse_tree[i] === "string") {
            output += parse_tree[i];
          } else if (typeof parse_tree[i] === "object") {
            ph = parse_tree[i];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports !== "undefined") {
        exports["sprintf"] = sprintf;
        exports["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/ipv4.js
var require_ipv4 = __commonJS({
  "node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/ipv4.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Address4 = void 0;
    var common = __importStar(require_common());
    var constants = __importStar(require_constants());
    var address_error_1 = require_address_error();
    var jsbn_1 = require_jsbn();
    var sprintf_js_1 = require_sprintf();
    var Address4 = (
      /** @class */
      function() {
        function Address42(address) {
          this.groups = constants.GROUPS;
          this.parsedAddress = [];
          this.parsedSubnet = "";
          this.subnet = "/32";
          this.subnetMask = 32;
          this.v4 = true;
          this.isCorrect = common.isCorrect(constants.BITS);
          this.isInSubnet = common.isInSubnet;
          this.address = address;
          var subnet = constants.RE_SUBNET_STRING.exec(address);
          if (subnet) {
            this.parsedSubnet = subnet[0].replace("/", "");
            this.subnetMask = parseInt(this.parsedSubnet, 10);
            this.subnet = "/" + this.subnetMask;
            if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
              throw new address_error_1.AddressError("Invalid subnet mask.");
            }
            address = address.replace(constants.RE_SUBNET_STRING, "");
          }
          this.addressMinusSuffix = address;
          this.parsedAddress = this.parse(address);
        }
        Address42.isValid = function(address) {
          try {
            new Address42(address);
            return true;
          } catch (e) {
            return false;
          }
        };
        Address42.prototype.parse = function(address) {
          var groups = address.split(".");
          if (!address.match(constants.RE_ADDRESS)) {
            throw new address_error_1.AddressError("Invalid IPv4 address.");
          }
          return groups;
        };
        Address42.prototype.correctForm = function() {
          return this.parsedAddress.map(function(part) {
            return parseInt(part, 10);
          }).join(".");
        };
        Address42.fromHex = function(hex) {
          var padded = hex.replace(/:/g, "").padStart(8, "0");
          var groups = [];
          var i;
          for (i = 0; i < 8; i += 2) {
            var h = padded.slice(i, i + 2);
            groups.push(parseInt(h, 16));
          }
          return new Address42(groups.join("."));
        };
        Address42.fromInteger = function(integer) {
          return Address42.fromHex(integer.toString(16));
        };
        Address42.prototype.toHex = function() {
          return this.parsedAddress.map(function(part) {
            return sprintf_js_1.sprintf("%02x", parseInt(part, 10));
          }).join(":");
        };
        Address42.prototype.toArray = function() {
          return this.parsedAddress.map(function(part) {
            return parseInt(part, 10);
          });
        };
        Address42.prototype.toGroup6 = function() {
          var output = [];
          var i;
          for (i = 0; i < constants.GROUPS; i += 2) {
            var hex = sprintf_js_1.sprintf("%02x%02x", parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));
            output.push(sprintf_js_1.sprintf("%x", parseInt(hex, 16)));
          }
          return output.join(":");
        };
        Address42.prototype.bigInteger = function() {
          return new jsbn_1.BigInteger(this.parsedAddress.map(function(n) {
            return sprintf_js_1.sprintf("%02x", parseInt(n, 10));
          }).join(""), 16);
        };
        Address42.prototype._startAddress = function() {
          return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants.BITS - this.subnetMask), 2);
        };
        Address42.prototype.startAddress = function() {
          return Address42.fromBigInteger(this._startAddress());
        };
        Address42.prototype.startAddressExclusive = function() {
          var adjust = new jsbn_1.BigInteger("1");
          return Address42.fromBigInteger(this._startAddress().add(adjust));
        };
        Address42.prototype._endAddress = function() {
          return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants.BITS - this.subnetMask), 2);
        };
        Address42.prototype.endAddress = function() {
          return Address42.fromBigInteger(this._endAddress());
        };
        Address42.prototype.endAddressExclusive = function() {
          var adjust = new jsbn_1.BigInteger("1");
          return Address42.fromBigInteger(this._endAddress().subtract(adjust));
        };
        Address42.fromBigInteger = function(bigInteger) {
          return Address42.fromInteger(parseInt(bigInteger.toString(), 10));
        };
        Address42.prototype.mask = function(mask) {
          if (mask === void 0) {
            mask = this.subnetMask;
          }
          return this.getBitsBase2(0, mask);
        };
        Address42.prototype.getBitsBase2 = function(start, end) {
          return this.binaryZeroPad().slice(start, end);
        };
        Address42.prototype.isMulticast = function() {
          return this.isInSubnet(new Address42("224.0.0.0/4"));
        };
        Address42.prototype.binaryZeroPad = function() {
          return this.bigInteger().toString(2).padStart(constants.BITS, "0");
        };
        Address42.prototype.groupForV6 = function() {
          var segments = this.parsedAddress;
          return this.address.replace(constants.RE_ADDRESS, sprintf_js_1.sprintf('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', segments.slice(0, 2).join("."), segments.slice(2, 4).join(".")));
        };
        return Address42;
      }()
    );
    exports.Address4 = Address4;
  }
});

// node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/v6/constants.js
var require_constants2 = __commonJS({
  "node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/v6/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RE_URL_WITH_PORT = exports.RE_URL = exports.RE_ZONE_STRING = exports.RE_SUBNET_STRING = exports.RE_BAD_ADDRESS = exports.RE_BAD_CHARACTERS = exports.TYPES = exports.SCOPES = exports.GROUPS = exports.BITS = void 0;
    exports.BITS = 128;
    exports.GROUPS = 8;
    exports.SCOPES = {
      0: "Reserved",
      1: "Interface local",
      2: "Link local",
      4: "Admin local",
      5: "Site local",
      8: "Organization local",
      14: "Global",
      15: "Reserved"
    };
    exports.TYPES = {
      "ff01::1/128": "Multicast (All nodes on this interface)",
      "ff01::2/128": "Multicast (All routers on this interface)",
      "ff02::1/128": "Multicast (All nodes on this link)",
      "ff02::2/128": "Multicast (All routers on this link)",
      "ff05::2/128": "Multicast (All routers in this site)",
      "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
      "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
      "ff02::9/128": "Multicast (RIP routers)",
      "ff02::a/128": "Multicast (EIGRP routers)",
      "ff02::d/128": "Multicast (PIM routers)",
      "ff02::16/128": "Multicast (MLDv2 reports)",
      "ff01::fb/128": "Multicast (mDNSv6)",
      "ff02::fb/128": "Multicast (mDNSv6)",
      "ff05::fb/128": "Multicast (mDNSv6)",
      "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
      "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
      "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
      "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
      "::/128": "Unspecified",
      "::1/128": "Loopback",
      "ff00::/8": "Multicast",
      "fe80::/10": "Link-local unicast"
    };
    exports.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
    exports.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
    exports.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
    exports.RE_ZONE_STRING = /%.*$/;
    exports.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
    exports.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
  }
});

// node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/v6/helpers.js
var require_helpers = __commonJS({
  "node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/v6/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.simpleGroup = exports.spanLeadingZeroes = exports.spanAll = exports.spanAllZeroes = void 0;
    var sprintf_js_1 = require_sprintf();
    function spanAllZeroes(s) {
      return s.replace(/(0+)/g, '<span class="zero">$1</span>');
    }
    exports.spanAllZeroes = spanAllZeroes;
    function spanAll(s, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var letters = s.split("");
      return letters.map(
        function(n, i) {
          return sprintf_js_1.sprintf('<span class="digit value-%s position-%d">%s</span>', n, i + offset, spanAllZeroes(n));
        }
        // XXX Use #base-2 .value-0 instead?
      ).join("");
    }
    exports.spanAll = spanAll;
    function spanLeadingZeroesSimple(group) {
      return group.replace(/^(0+)/, '<span class="zero">$1</span>');
    }
    function spanLeadingZeroes(address) {
      var groups = address.split(":");
      return groups.map(function(g) {
        return spanLeadingZeroesSimple(g);
      }).join(":");
    }
    exports.spanLeadingZeroes = spanLeadingZeroes;
    function simpleGroup(addressString, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var groups = addressString.split(":");
      return groups.map(function(g, i) {
        if (/group-v4/.test(g)) {
          return g;
        }
        return sprintf_js_1.sprintf('<span class="hover-group group-%d">%s</span>', i + offset, spanLeadingZeroesSimple(g));
      });
    }
    exports.simpleGroup = simpleGroup;
  }
});

// node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/v6/regular-expressions.js
var require_regular_expressions = __commonJS({
  "node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/v6/regular-expressions.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.possibleElisions = exports.simpleRegularExpression = exports.ADDRESS_BOUNDARY = exports.padGroup = exports.groupPossibilities = void 0;
    var v6 = __importStar(require_constants2());
    var sprintf_js_1 = require_sprintf();
    function groupPossibilities(possibilities) {
      return sprintf_js_1.sprintf("(%s)", possibilities.join("|"));
    }
    exports.groupPossibilities = groupPossibilities;
    function padGroup(group) {
      if (group.length < 4) {
        return sprintf_js_1.sprintf("0{0,%d}%s", 4 - group.length, group);
      }
      return group;
    }
    exports.padGroup = padGroup;
    exports.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
    function simpleRegularExpression(groups) {
      var zeroIndexes = [];
      groups.forEach(function(group, i) {
        var groupInteger = parseInt(group, 16);
        if (groupInteger === 0) {
          zeroIndexes.push(i);
        }
      });
      var possibilities = zeroIndexes.map(function(zeroIndex) {
        return groups.map(function(group, i) {
          if (i === zeroIndex) {
            var elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
            return groupPossibilities([padGroup(group), elision]);
          }
          return padGroup(group);
        }).join(":");
      });
      possibilities.push(groups.map(padGroup).join(":"));
      return groupPossibilities(possibilities);
    }
    exports.simpleRegularExpression = simpleRegularExpression;
    function possibleElisions(elidedGroups, moreLeft, moreRight) {
      var left = moreLeft ? "" : ":";
      var right = moreRight ? "" : ":";
      var possibilities = [];
      if (!moreLeft && !moreRight) {
        possibilities.push("::");
      }
      if (moreLeft && moreRight) {
        possibilities.push("");
      }
      if (moreRight && !moreLeft || !moreRight && moreLeft) {
        possibilities.push(":");
      }
      possibilities.push(sprintf_js_1.sprintf("%s(:0{1,4}){1,%d}", left, elidedGroups - 1));
      possibilities.push(sprintf_js_1.sprintf("(0{1,4}:){1,%d}%s", elidedGroups - 1, right));
      possibilities.push(sprintf_js_1.sprintf("(0{1,4}:){%d}0{1,4}", elidedGroups - 1));
      for (var groups = 1; groups < elidedGroups - 1; groups++) {
        for (var position = 1; position < elidedGroups - groups; position++) {
          possibilities.push(sprintf_js_1.sprintf("(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}", position, elidedGroups - position - groups - 1));
        }
      }
      return groupPossibilities(possibilities);
    }
    exports.possibleElisions = possibleElisions;
  }
});

// node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/ipv6.js
var require_ipv6 = __commonJS({
  "node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/lib/ipv6.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __spreadArrays = exports && exports.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Address6 = void 0;
    var common = __importStar(require_common());
    var constants4 = __importStar(require_constants());
    var constants6 = __importStar(require_constants2());
    var helpers = __importStar(require_helpers());
    var ipv4_1 = require_ipv4();
    var regular_expressions_1 = require_regular_expressions();
    var address_error_1 = require_address_error();
    var jsbn_1 = require_jsbn();
    var sprintf_js_1 = require_sprintf();
    function assert(condition) {
      if (!condition) {
        throw new Error("Assertion failed.");
      }
    }
    function addCommas(number) {
      var r = /(\d+)(\d{3})/;
      while (r.test(number)) {
        number = number.replace(r, "$1,$2");
      }
      return number;
    }
    function spanLeadingZeroes4(n) {
      n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
      n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
      return n;
    }
    function compact(address, slice) {
      var s1 = [];
      var s2 = [];
      var i;
      for (i = 0; i < address.length; i++) {
        if (i < slice[0]) {
          s1.push(address[i]);
        } else if (i > slice[1]) {
          s2.push(address[i]);
        }
      }
      return s1.concat(["compact"]).concat(s2);
    }
    function paddedHex(octet) {
      return sprintf_js_1.sprintf("%04x", parseInt(octet, 16));
    }
    function unsignByte(b) {
      return b & 255;
    }
    var Address6 = (
      /** @class */
      function() {
        function Address62(address, optionalGroups) {
          this.addressMinusSuffix = "";
          this.parsedSubnet = "";
          this.subnet = "/128";
          this.subnetMask = 128;
          this.v4 = false;
          this.zone = "";
          this.isInSubnet = common.isInSubnet;
          this.isCorrect = common.isCorrect(constants6.BITS);
          if (optionalGroups === void 0) {
            this.groups = constants6.GROUPS;
          } else {
            this.groups = optionalGroups;
          }
          this.address = address;
          var subnet = constants6.RE_SUBNET_STRING.exec(address);
          if (subnet) {
            this.parsedSubnet = subnet[0].replace("/", "");
            this.subnetMask = parseInt(this.parsedSubnet, 10);
            this.subnet = "/" + this.subnetMask;
            if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
              throw new address_error_1.AddressError("Invalid subnet mask.");
            }
            address = address.replace(constants6.RE_SUBNET_STRING, "");
          } else if (/\//.test(address)) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          var zone = constants6.RE_ZONE_STRING.exec(address);
          if (zone) {
            this.zone = zone[0];
            address = address.replace(constants6.RE_ZONE_STRING, "");
          }
          this.addressMinusSuffix = address;
          this.parsedAddress = this.parse(this.addressMinusSuffix);
        }
        Address62.isValid = function(address) {
          try {
            new Address62(address);
            return true;
          } catch (e) {
            return false;
          }
        };
        Address62.fromBigInteger = function(bigInteger) {
          var hex = bigInteger.toString(16).padStart(32, "0");
          var groups = [];
          var i;
          for (i = 0; i < constants6.GROUPS; i++) {
            groups.push(hex.slice(i * 4, (i + 1) * 4));
          }
          return new Address62(groups.join(":"));
        };
        Address62.fromURL = function(url) {
          var host;
          var port = null;
          var result;
          if (url.indexOf("[") !== -1 && url.indexOf("]:") !== -1) {
            result = constants6.RE_URL_WITH_PORT.exec(url);
            if (result === null) {
              return {
                error: "failed to parse address with port",
                address: null,
                port: null
              };
            }
            host = result[1];
            port = result[2];
          } else if (url.indexOf("/") !== -1) {
            url = url.replace(/^[a-z0-9]+:\/\//, "");
            result = constants6.RE_URL.exec(url);
            if (result === null) {
              return {
                error: "failed to parse address from URL",
                address: null,
                port: null
              };
            }
            host = result[1];
          } else {
            host = url;
          }
          if (port) {
            port = parseInt(port, 10);
            if (port < 0 || port > 65536) {
              port = null;
            }
          } else {
            port = null;
          }
          return {
            address: new Address62(host),
            port
          };
        };
        Address62.fromAddress4 = function(address) {
          var address4 = new ipv4_1.Address4(address);
          var mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
          return new Address62("::ffff:" + address4.correctForm() + "/" + mask6);
        };
        Address62.fromArpa = function(arpaFormAddress) {
          var address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
          var semicolonAmount = 7;
          if (address.length !== 63) {
            throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
          }
          var parts = address.split(".").reverse();
          for (var i = semicolonAmount; i > 0; i--) {
            var insertIndex = i * 4;
            parts.splice(insertIndex, 0, ":");
          }
          address = parts.join("");
          return new Address62(address);
        };
        Address62.prototype.microsoftTranscription = function() {
          return sprintf_js_1.sprintf("%s.ipv6-literal.net", this.correctForm().replace(/:/g, "-"));
        };
        Address62.prototype.mask = function(mask) {
          if (mask === void 0) {
            mask = this.subnetMask;
          }
          return this.getBitsBase2(0, mask);
        };
        Address62.prototype.possibleSubnets = function(subnetSize) {
          if (subnetSize === void 0) {
            subnetSize = 128;
          }
          var availableBits = constants6.BITS - this.subnetMask;
          var subnetBits = Math.abs(subnetSize - constants6.BITS);
          var subnetPowers = availableBits - subnetBits;
          if (subnetPowers < 0) {
            return "0";
          }
          return addCommas(new jsbn_1.BigInteger("2", 10).pow(subnetPowers).toString(10));
        };
        Address62.prototype._startAddress = function() {
          return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants6.BITS - this.subnetMask), 2);
        };
        Address62.prototype.startAddress = function() {
          return Address62.fromBigInteger(this._startAddress());
        };
        Address62.prototype.startAddressExclusive = function() {
          var adjust = new jsbn_1.BigInteger("1");
          return Address62.fromBigInteger(this._startAddress().add(adjust));
        };
        Address62.prototype._endAddress = function() {
          return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants6.BITS - this.subnetMask), 2);
        };
        Address62.prototype.endAddress = function() {
          return Address62.fromBigInteger(this._endAddress());
        };
        Address62.prototype.endAddressExclusive = function() {
          var adjust = new jsbn_1.BigInteger("1");
          return Address62.fromBigInteger(this._endAddress().subtract(adjust));
        };
        Address62.prototype.getScope = function() {
          var scope = constants6.SCOPES[this.getBits(12, 16).intValue()];
          if (this.getType() === "Global unicast" && scope !== "Link local") {
            scope = "Global";
          }
          return scope || "Unknown";
        };
        Address62.prototype.getType = function() {
          for (var _i = 0, _a = Object.keys(constants6.TYPES); _i < _a.length; _i++) {
            var subnet = _a[_i];
            if (this.isInSubnet(new Address62(subnet))) {
              return constants6.TYPES[subnet];
            }
          }
          return "Global unicast";
        };
        Address62.prototype.getBits = function(start, end) {
          return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);
        };
        Address62.prototype.getBitsBase2 = function(start, end) {
          return this.binaryZeroPad().slice(start, end);
        };
        Address62.prototype.getBitsBase16 = function(start, end) {
          var length = end - start;
          if (length % 4 !== 0) {
            throw new Error("Length of bits to retrieve must be divisible by four");
          }
          return this.getBits(start, end).toString(16).padStart(length / 4, "0");
        };
        Address62.prototype.getBitsPastSubnet = function() {
          return this.getBitsBase2(this.subnetMask, constants6.BITS);
        };
        Address62.prototype.reverseForm = function(options) {
          if (!options) {
            options = {};
          }
          var characters = Math.floor(this.subnetMask / 4);
          var reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
          if (characters > 0) {
            if (options.omitSuffix) {
              return reversed;
            }
            return sprintf_js_1.sprintf("%s.ip6.arpa.", reversed);
          }
          if (options.omitSuffix) {
            return "";
          }
          return "ip6.arpa.";
        };
        Address62.prototype.correctForm = function() {
          var i;
          var groups = [];
          var zeroCounter = 0;
          var zeroes = [];
          for (i = 0; i < this.parsedAddress.length; i++) {
            var value = parseInt(this.parsedAddress[i], 16);
            if (value === 0) {
              zeroCounter++;
            }
            if (value !== 0 && zeroCounter > 0) {
              if (zeroCounter > 1) {
                zeroes.push([i - zeroCounter, i - 1]);
              }
              zeroCounter = 0;
            }
          }
          if (zeroCounter > 1) {
            zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
          }
          var zeroLengths = zeroes.map(function(n) {
            return n[1] - n[0] + 1;
          });
          if (zeroes.length > 0) {
            var index = zeroLengths.indexOf(Math.max.apply(Math, zeroLengths));
            groups = compact(this.parsedAddress, zeroes[index]);
          } else {
            groups = this.parsedAddress;
          }
          for (i = 0; i < groups.length; i++) {
            if (groups[i] !== "compact") {
              groups[i] = parseInt(groups[i], 16).toString(16);
            }
          }
          var correct = groups.join(":");
          correct = correct.replace(/^compact$/, "::");
          correct = correct.replace(/^compact|compact$/, ":");
          correct = correct.replace(/compact/, "");
          return correct;
        };
        Address62.prototype.binaryZeroPad = function() {
          return this.bigInteger().toString(2).padStart(constants6.BITS, "0");
        };
        Address62.prototype.parse4in6 = function(address) {
          var groups = address.split(":");
          var lastGroup = groups.slice(-1)[0];
          var address4 = lastGroup.match(constants4.RE_ADDRESS);
          if (address4) {
            this.parsedAddress4 = address4[0];
            this.address4 = new ipv4_1.Address4(this.parsedAddress4);
            for (var i = 0; i < this.address4.groups; i++) {
              if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
                throw new address_error_1.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join(".")));
              }
            }
            this.v4 = true;
            groups[groups.length - 1] = this.address4.toGroup6();
            address = groups.join(":");
          }
          return address;
        };
        Address62.prototype.parse = function(address) {
          address = this.parse4in6(address);
          var badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
          if (badCharacters) {
            throw new address_error_1.AddressError(sprintf_js_1.sprintf("Bad character%s detected in address: %s", badCharacters.length > 1 ? "s" : "", badCharacters.join("")), address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
          }
          var badAddress = address.match(constants6.RE_BAD_ADDRESS);
          if (badAddress) {
            throw new address_error_1.AddressError(sprintf_js_1.sprintf("Address failed regex: %s", badAddress.join("")), address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
          }
          var groups = [];
          var halves = address.split("::");
          if (halves.length === 2) {
            var first = halves[0].split(":");
            var last = halves[1].split(":");
            if (first.length === 1 && first[0] === "") {
              first = [];
            }
            if (last.length === 1 && last[0] === "") {
              last = [];
            }
            var remaining = this.groups - (first.length + last.length);
            if (!remaining) {
              throw new address_error_1.AddressError("Error parsing groups");
            }
            this.elidedGroups = remaining;
            this.elisionBegin = first.length;
            this.elisionEnd = first.length + this.elidedGroups;
            groups = groups.concat(first);
            for (var i = 0; i < remaining; i++) {
              groups.push("0");
            }
            groups = groups.concat(last);
          } else if (halves.length === 1) {
            groups = address.split(":");
            this.elidedGroups = 0;
          } else {
            throw new address_error_1.AddressError("Too many :: groups found");
          }
          groups = groups.map(function(group) {
            return sprintf_js_1.sprintf("%x", parseInt(group, 16));
          });
          if (groups.length !== this.groups) {
            throw new address_error_1.AddressError("Incorrect number of groups found");
          }
          return groups;
        };
        Address62.prototype.canonicalForm = function() {
          return this.parsedAddress.map(paddedHex).join(":");
        };
        Address62.prototype.decimal = function() {
          return this.parsedAddress.map(function(n) {
            return sprintf_js_1.sprintf("%05d", parseInt(n, 16));
          }).join(":");
        };
        Address62.prototype.bigInteger = function() {
          return new jsbn_1.BigInteger(this.parsedAddress.map(paddedHex).join(""), 16);
        };
        Address62.prototype.to4 = function() {
          var binary = this.binaryZeroPad().split("");
          return ipv4_1.Address4.fromHex(new jsbn_1.BigInteger(binary.slice(96, 128).join(""), 2).toString(16));
        };
        Address62.prototype.to4in6 = function() {
          var address4 = this.to4();
          var address6 = new Address62(this.parsedAddress.slice(0, 6).join(":"), 6);
          var correct = address6.correctForm();
          var infix = "";
          if (!/:$/.test(correct)) {
            infix = ":";
          }
          return correct + infix + address4.address;
        };
        Address62.prototype.inspectTeredo = function() {
          var prefix = this.getBitsBase16(0, 32);
          var udpPort = this.getBits(80, 96).xor(new jsbn_1.BigInteger("ffff", 16)).toString();
          var server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
          var client4 = ipv4_1.Address4.fromHex(this.getBits(96, 128).xor(new jsbn_1.BigInteger("ffffffff", 16)).toString(16));
          var flags = this.getBits(64, 80);
          var flagsBase2 = this.getBitsBase2(64, 80);
          var coneNat = flags.testBit(15);
          var reserved = flags.testBit(14);
          var groupIndividual = flags.testBit(8);
          var universalLocal = flags.testBit(9);
          var nonce = new jsbn_1.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);
          return {
            prefix: sprintf_js_1.sprintf("%s:%s", prefix.slice(0, 4), prefix.slice(4, 8)),
            server4: server4.address,
            client4: client4.address,
            flags: flagsBase2,
            coneNat,
            microsoft: {
              reserved,
              universalLocal,
              groupIndividual,
              nonce
            },
            udpPort
          };
        };
        Address62.prototype.inspect6to4 = function() {
          var prefix = this.getBitsBase16(0, 16);
          var gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
          return {
            prefix: sprintf_js_1.sprintf("%s", prefix.slice(0, 4)),
            gateway: gateway.address
          };
        };
        Address62.prototype.to6to4 = function() {
          if (!this.is4()) {
            return null;
          }
          var addr6to4 = [
            "2002",
            this.getBitsBase16(96, 112),
            this.getBitsBase16(112, 128),
            "",
            "/16"
          ].join(":");
          return new Address62(addr6to4);
        };
        Address62.prototype.toByteArray = function() {
          var byteArray = this.bigInteger().toByteArray();
          if (byteArray.length === 17 && byteArray[0] === 0) {
            return byteArray.slice(1);
          }
          return byteArray;
        };
        Address62.prototype.toUnsignedByteArray = function() {
          return this.toByteArray().map(unsignByte);
        };
        Address62.fromByteArray = function(bytes) {
          return this.fromUnsignedByteArray(bytes.map(unsignByte));
        };
        Address62.fromUnsignedByteArray = function(bytes) {
          var BYTE_MAX = new jsbn_1.BigInteger("256", 10);
          var result = new jsbn_1.BigInteger("0", 10);
          var multiplier = new jsbn_1.BigInteger("1", 10);
          for (var i = bytes.length - 1; i >= 0; i--) {
            result = result.add(multiplier.multiply(new jsbn_1.BigInteger(bytes[i].toString(10), 10)));
            multiplier = multiplier.multiply(BYTE_MAX);
          }
          return Address62.fromBigInteger(result);
        };
        Address62.prototype.isCanonical = function() {
          return this.addressMinusSuffix === this.canonicalForm();
        };
        Address62.prototype.isLinkLocal = function() {
          if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
            return true;
          }
          return false;
        };
        Address62.prototype.isMulticast = function() {
          return this.getType() === "Multicast";
        };
        Address62.prototype.is4 = function() {
          return this.v4;
        };
        Address62.prototype.isTeredo = function() {
          return this.isInSubnet(new Address62("2001::/32"));
        };
        Address62.prototype.is6to4 = function() {
          return this.isInSubnet(new Address62("2002::/16"));
        };
        Address62.prototype.isLoopback = function() {
          return this.getType() === "Loopback";
        };
        Address62.prototype.href = function(optionalPort) {
          if (optionalPort === void 0) {
            optionalPort = "";
          } else {
            optionalPort = sprintf_js_1.sprintf(":%s", optionalPort);
          }
          return sprintf_js_1.sprintf("http://[%s]%s/", this.correctForm(), optionalPort);
        };
        Address62.prototype.link = function(options) {
          if (!options) {
            options = {};
          }
          if (options.className === void 0) {
            options.className = "";
          }
          if (options.prefix === void 0) {
            options.prefix = "/#address=";
          }
          if (options.v4 === void 0) {
            options.v4 = false;
          }
          var formFunction = this.correctForm;
          if (options.v4) {
            formFunction = this.to4in6;
          }
          if (options.className) {
            return sprintf_js_1.sprintf('<a href="%1$s%2$s" class="%3$s">%2$s</a>', options.prefix, formFunction.call(this), options.className);
          }
          return sprintf_js_1.sprintf('<a href="%1$s%2$s">%2$s</a>', options.prefix, formFunction.call(this));
        };
        Address62.prototype.group = function() {
          if (this.elidedGroups === 0) {
            return helpers.simpleGroup(this.address).join(":");
          }
          assert(typeof this.elidedGroups === "number");
          assert(typeof this.elisionBegin === "number");
          var output = [];
          var _a = this.address.split("::"), left = _a[0], right = _a[1];
          if (left.length) {
            output.push.apply(output, helpers.simpleGroup(left));
          } else {
            output.push("");
          }
          var classes = ["hover-group"];
          for (var i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {
            classes.push(sprintf_js_1.sprintf("group-%d", i));
          }
          output.push(sprintf_js_1.sprintf('<span class="%s"></span>', classes.join(" ")));
          if (right.length) {
            output.push.apply(output, helpers.simpleGroup(right, this.elisionEnd));
          } else {
            output.push("");
          }
          if (this.is4()) {
            assert(this.address4 instanceof ipv4_1.Address4);
            output.pop();
            output.push(this.address4.groupForV6());
          }
          return output.join(":");
        };
        Address62.prototype.regularExpressionString = function(substringSearch) {
          if (substringSearch === void 0) {
            substringSearch = false;
          }
          var output = [];
          var address6 = new Address62(this.correctForm());
          if (address6.elidedGroups === 0) {
            output.push(regular_expressions_1.simpleRegularExpression(address6.parsedAddress));
          } else if (address6.elidedGroups === constants6.GROUPS) {
            output.push(regular_expressions_1.possibleElisions(constants6.GROUPS));
          } else {
            var halves = address6.address.split("::");
            if (halves[0].length) {
              output.push(regular_expressions_1.simpleRegularExpression(halves[0].split(":")));
            }
            assert(typeof address6.elidedGroups === "number");
            output.push(regular_expressions_1.possibleElisions(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
            if (halves[1].length) {
              output.push(regular_expressions_1.simpleRegularExpression(halves[1].split(":")));
            }
            output = [output.join(":")];
          }
          if (!substringSearch) {
            output = __spreadArrays([
              "(?=^|",
              regular_expressions_1.ADDRESS_BOUNDARY,
              "|[^\\w\\:])("
            ], output, [
              ")(?=[^\\w\\:]|",
              regular_expressions_1.ADDRESS_BOUNDARY,
              "|$)"
            ]);
          }
          return output.join("");
        };
        Address62.prototype.regularExpression = function(substringSearch) {
          if (substringSearch === void 0) {
            substringSearch = false;
          }
          return new RegExp(this.regularExpressionString(substringSearch), "i");
        };
        return Address62;
      }()
    );
    exports.Address6 = Address6;
  }
});

// node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/ip-address.js
var require_ip_address = __commonJS({
  "node_modules/.pnpm/ip-address@7.1.0/node_modules/ip-address/dist/ip-address.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.v6 = exports.Address6 = exports.Address4 = void 0;
    var ipv4_1 = require_ipv4();
    Object.defineProperty(exports, "Address4", { enumerable: true, get: function() {
      return ipv4_1.Address4;
    } });
    var ipv6_1 = require_ipv6();
    Object.defineProperty(exports, "Address6", { enumerable: true, get: function() {
      return ipv6_1.Address6;
    } });
    var helpers = __importStar(require_helpers());
    exports.v6 = { helpers };
  }
});

// node_modules/.pnpm/ip-cidr@3.1.0/node_modules/ip-cidr/index.js
var require_ip_cidr = __commonJS({
  "node_modules/.pnpm/ip-cidr@3.1.0/node_modules/ip-cidr/index.js"(exports, module) {
    "use strict";
    var ipAddress = require_ip_address();
    var BigInteger = require_jsbn().BigInteger;
    var IPCIDR2 = class {
      constructor(cidr) {
        if (typeof cidr !== "string" || !cidr.match("/")) {
          throw new Error("Invalid CIDR address.");
        }
        const address = this.constructor.createAddress(cidr);
        this.cidr = address.address;
        this.ipAddressType = address.constructor;
        this.address = address;
        this.addressStart = address.startAddress();
        this.addressEnd = address.endAddress();
        this.addressStart.subnet = this.addressEnd.subnet = this.address.subnet;
        this.addressStart.subnetMask = this.addressEnd.subnetMask = this.address.subnetMask;
        this.size = new BigInteger(this.addressEnd.bigInteger().subtract(this.addressStart.bigInteger()).add(new BigInteger("1")).toString());
      }
      contains(address) {
        try {
          if (!(address instanceof ipAddress.Address6) && !(address instanceof ipAddress.Address4)) {
            if (typeof address == "object") {
              address = this.ipAddressType.fromBigInteger(address);
            } else {
              address = this.constructor.createAddress(address);
            }
          }
          return address.isInSubnet(this.address);
        } catch (err) {
          return false;
        }
      }
      start(options) {
        return this.constructor.formatIP(this.addressStart, options);
      }
      end(options) {
        return this.constructor.formatIP(this.addressEnd, options);
      }
      toString() {
        return this.cidr;
      }
      toRange(options) {
        return [this.constructor.formatIP(this.addressStart, options), this.constructor.formatIP(this.addressEnd, options)];
      }
      toObject(options) {
        return {
          start: this.constructor.formatIP(this.addressStart, options),
          end: this.constructor.formatIP(this.addressEnd, options)
        };
      }
      toArray(options, results) {
        options = options || {};
        const list = [];
        const start = this.constructor.formatIP(this.addressStart, { type: "bigInteger" });
        const end = this.constructor.formatIP(this.addressEnd, { type: "bigInteger" });
        const length = end.subtract(start).add(new BigInteger("1"));
        const info = this.getChunkInfo(length, options);
        if (results) {
          Object.assign(results, info);
        }
        this.loopInfo(info, (val) => {
          const num = start.add(val);
          const ip = this.constructor.formatIP(this.ipAddressType.fromBigInteger(num), options);
          list.push(ip);
        });
        return list;
      }
      loop(fn, options, results) {
        options = options || {};
        const promise = [];
        const start = this.constructor.formatIP(this.addressStart, { type: "bigInteger" });
        const end = this.constructor.formatIP(this.addressEnd, { type: "bigInteger" });
        const length = end.subtract(start).add(new BigInteger("1"));
        const info = this.getChunkInfo(length, options);
        if (results) {
          Object.assign(results, info);
        }
        this.loopInfo(info, (val) => {
          const num = start.add(val);
          const ip = this.constructor.formatIP(this.ipAddressType.fromBigInteger(num), options);
          promise.push(fn(ip));
        });
        return Promise.all(promise);
      }
      loopInfo(info, fn) {
        let i = info.from;
        while (i.compareTo(info.to) < 0) {
          fn(i);
          i = i.add(new BigInteger("1"));
        }
      }
      getChunkInfo(length, options) {
        let from = options.from;
        let limit = options.limit;
        let to = options.to;
        let maxLength;
        const addressBigInteger = this.constructor.formatIP(this.address, { type: "bigInteger" });
        const getBigInteger = (val) => {
          if (typeof val == "string" && val.match(/:|\./)) {
            return this.constructor.formatIP(this.constructor.createAddress(val), { type: "bigInteger" }).subtract(addressBigInteger);
          } else if (typeof val != "object") {
            return new BigInteger(val + "");
          }
          return val;
        };
        from = getBigInteger(from !== void 0 ? from : 0);
        if (to !== void 0) {
          to = getBigInteger(to);
          limit = to.subtract(from);
        } else {
          limit = limit !== void 0 ? getBigInteger(limit) : length;
        }
        maxLength = length.subtract(from);
        if (limit.compareTo(maxLength) > 0) {
          limit = maxLength;
        }
        to = from.add(limit);
        return {
          from,
          to,
          limit,
          length
        };
      }
    };
    IPCIDR2.formatIP = function(address, options) {
      options = options || {};
      if (options.type == "bigInteger") {
        return new BigInteger(address.bigInteger().toString());
      } else if (options.type == "addressObject") {
        return address;
      }
      return address.addressMinusSuffix;
    };
    IPCIDR2.createAddress = function(val) {
      if (typeof val !== "string") {
        throw new Error("Invalid IP address.");
      }
      val.match(/:.\./) && (val = val.split(":").pop());
      const ipAddressType = val.match(":") ? ipAddress.Address6 : ipAddress.Address4;
      let ip = new ipAddressType(val);
      if (ip.v4 && val.match(":") && ip.address4) {
        ip = ip.address4;
      }
      if (ip.v4) {
        const parts = ip.addressMinusSuffix.split(".");
        for (let i = 0; i < parts.length; i++) {
          const part = parts[i].split("/")[0];
          if (part[0] == "0" && part.length > 1) {
            throw new Error("Invalid IPv4 address.");
          }
        }
      }
      return ip;
    };
    IPCIDR2.isValidAddress = function(address) {
      try {
        return !!this.createAddress(address);
      } catch (err) {
        return false;
      }
    };
    IPCIDR2.isValidCIDR = function(address) {
      if (typeof address !== "string" || !address.match("/")) {
        return false;
      }
      try {
        return !!this.createAddress(address);
      } catch (err) {
        return false;
      }
    };
    module.exports = IPCIDR2;
  }
});

// node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Pattern.js
var require_Pattern = __commonJS({
  "node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Pattern.js"(exports, module) {
    var Pattern2;
    Pattern2 = function() {
      Pattern3.prototype.regex = null;
      Pattern3.prototype.rawRegex = null;
      Pattern3.prototype.cleanedRegex = null;
      Pattern3.prototype.mapping = null;
      function Pattern3(rawRegex, modifiers) {
        var _char, capturingBracketNumber, cleanedRegex, i, len, mapping, name, part, subChar;
        if (modifiers == null) {
          modifiers = "";
        }
        cleanedRegex = "";
        len = rawRegex.length;
        mapping = null;
        capturingBracketNumber = 0;
        i = 0;
        while (i < len) {
          _char = rawRegex.charAt(i);
          if (_char === "\\") {
            cleanedRegex += rawRegex.slice(i, +(i + 1) + 1 || 9e9);
            i++;
          } else if (_char === "(") {
            if (i < len - 2) {
              part = rawRegex.slice(i, +(i + 2) + 1 || 9e9);
              if (part === "(?:") {
                i += 2;
                cleanedRegex += part;
              } else if (part === "(?<") {
                capturingBracketNumber++;
                i += 2;
                name = "";
                while (i + 1 < len) {
                  subChar = rawRegex.charAt(i + 1);
                  if (subChar === ">") {
                    cleanedRegex += "(";
                    i++;
                    if (name.length > 0) {
                      if (mapping == null) {
                        mapping = {};
                      }
                      mapping[name] = capturingBracketNumber;
                    }
                    break;
                  } else {
                    name += subChar;
                  }
                  i++;
                }
              } else {
                cleanedRegex += _char;
                capturingBracketNumber++;
              }
            } else {
              cleanedRegex += _char;
            }
          } else {
            cleanedRegex += _char;
          }
          i++;
        }
        this.rawRegex = rawRegex;
        this.cleanedRegex = cleanedRegex;
        this.regex = new RegExp(this.cleanedRegex, "g" + modifiers.replace("g", ""));
        this.mapping = mapping;
      }
      Pattern3.prototype.exec = function(str) {
        var index, matches, name, ref;
        this.regex.lastIndex = 0;
        matches = this.regex.exec(str);
        if (matches == null) {
          return null;
        }
        if (this.mapping != null) {
          ref = this.mapping;
          for (name in ref) {
            index = ref[name];
            matches[name] = matches[index];
          }
        }
        return matches;
      };
      Pattern3.prototype.test = function(str) {
        this.regex.lastIndex = 0;
        return this.regex.test(str);
      };
      Pattern3.prototype.replace = function(str, replacement) {
        this.regex.lastIndex = 0;
        return str.replace(this.regex, replacement);
      };
      Pattern3.prototype.replaceAll = function(str, replacement, limit) {
        var count;
        if (limit == null) {
          limit = 0;
        }
        this.regex.lastIndex = 0;
        count = 0;
        while (this.regex.test(str) && (limit === 0 || count < limit)) {
          this.regex.lastIndex = 0;
          str = str.replace(this.regex, replacement);
          count++;
        }
        return [str, count];
      };
      return Pattern3;
    }();
    module.exports = Pattern2;
  }
});

// node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Utils.js
var require_Utils = __commonJS({
  "node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Utils.js"(exports, module) {
    var Pattern2;
    var Utils;
    var hasProp = {}.hasOwnProperty;
    Pattern2 = require_Pattern();
    Utils = function() {
      function Utils2() {
      }
      Utils2.REGEX_LEFT_TRIM_BY_CHAR = {};
      Utils2.REGEX_RIGHT_TRIM_BY_CHAR = {};
      Utils2.REGEX_SPACES = /\s+/g;
      Utils2.REGEX_DIGITS = /^\d+$/;
      Utils2.REGEX_OCTAL = /[^0-7]/gi;
      Utils2.REGEX_HEXADECIMAL = /[^a-f0-9]/gi;
      Utils2.PATTERN_DATE = new Pattern2("^(?<year>[0-9][0-9][0-9][0-9])-(?<month>[0-9][0-9]?)-(?<day>[0-9][0-9]?)(?:(?:[Tt]|[ 	]+)(?<hour>[0-9][0-9]?):(?<minute>[0-9][0-9]):(?<second>[0-9][0-9])(?:.(?<fraction>[0-9]*))?(?:[ 	]*(?<tz>Z|(?<tz_sign>[-+])(?<tz_hour>[0-9][0-9]?)(?::(?<tz_minute>[0-9][0-9]))?))?)?$", "i");
      Utils2.LOCAL_TIMEZONE_OFFSET = (/* @__PURE__ */ new Date()).getTimezoneOffset() * 60 * 1e3;
      Utils2.trim = function(str, _char) {
        var regexLeft, regexRight;
        if (_char == null) {
          _char = "\\s";
        }
        regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];
        if (regexLeft == null) {
          this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp("^" + _char + _char + "*");
        }
        regexLeft.lastIndex = 0;
        regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];
        if (regexRight == null) {
          this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + "" + _char + "*$");
        }
        regexRight.lastIndex = 0;
        return str.replace(regexLeft, "").replace(regexRight, "");
      };
      Utils2.ltrim = function(str, _char) {
        var regexLeft;
        if (_char == null) {
          _char = "\\s";
        }
        regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];
        if (regexLeft == null) {
          this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp("^" + _char + _char + "*");
        }
        regexLeft.lastIndex = 0;
        return str.replace(regexLeft, "");
      };
      Utils2.rtrim = function(str, _char) {
        var regexRight;
        if (_char == null) {
          _char = "\\s";
        }
        regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];
        if (regexRight == null) {
          this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + "" + _char + "*$");
        }
        regexRight.lastIndex = 0;
        return str.replace(regexRight, "");
      };
      Utils2.isEmpty = function(value) {
        return !value || value === "" || value === "0" || value instanceof Array && value.length === 0 || this.isEmptyObject(value);
      };
      Utils2.isEmptyObject = function(value) {
        var k;
        return value instanceof Object && function() {
          var results;
          results = [];
          for (k in value) {
            if (!hasProp.call(value, k))
              continue;
            results.push(k);
          }
          return results;
        }().length === 0;
      };
      Utils2.subStrCount = function(string, subString, start, length) {
        var c, i, j, len, ref, sublen;
        c = 0;
        string = "" + string;
        subString = "" + subString;
        if (start != null) {
          string = string.slice(start);
        }
        if (length != null) {
          string = string.slice(0, length);
        }
        len = string.length;
        sublen = subString.length;
        for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          if (subString === string.slice(i, sublen)) {
            c++;
            i += sublen - 1;
          }
        }
        return c;
      };
      Utils2.isDigits = function(input) {
        this.REGEX_DIGITS.lastIndex = 0;
        return this.REGEX_DIGITS.test(input);
      };
      Utils2.octDec = function(input) {
        this.REGEX_OCTAL.lastIndex = 0;
        return parseInt((input + "").replace(this.REGEX_OCTAL, ""), 8);
      };
      Utils2.hexDec = function(input) {
        this.REGEX_HEXADECIMAL.lastIndex = 0;
        input = this.trim(input);
        if ((input + "").slice(0, 2) === "0x") {
          input = (input + "").slice(2);
        }
        return parseInt((input + "").replace(this.REGEX_HEXADECIMAL, ""), 16);
      };
      Utils2.utf8chr = function(c) {
        var ch;
        ch = String.fromCharCode;
        if (128 > (c %= 2097152)) {
          return ch(c);
        }
        if (2048 > c) {
          return ch(192 | c >> 6) + ch(128 | c & 63);
        }
        if (65536 > c) {
          return ch(224 | c >> 12) + ch(128 | c >> 6 & 63) + ch(128 | c & 63);
        }
        return ch(240 | c >> 18) + ch(128 | c >> 12 & 63) + ch(128 | c >> 6 & 63) + ch(128 | c & 63);
      };
      Utils2.parseBoolean = function(input, strict) {
        var lowerInput;
        if (strict == null) {
          strict = true;
        }
        if (typeof input === "string") {
          lowerInput = input.toLowerCase();
          if (!strict) {
            if (lowerInput === "no") {
              return false;
            }
          }
          if (lowerInput === "0") {
            return false;
          }
          if (lowerInput === "false") {
            return false;
          }
          if (lowerInput === "") {
            return false;
          }
          return true;
        }
        return !!input;
      };
      Utils2.isNumeric = function(input) {
        this.REGEX_SPACES.lastIndex = 0;
        return typeof input === "number" || typeof input === "string" && !isNaN(input) && input.replace(this.REGEX_SPACES, "") !== "";
      };
      Utils2.stringToDate = function(str) {
        var date, day, fraction, hour, info, minute, month, second, tz_hour, tz_minute, tz_offset, year;
        if (!(str != null ? str.length : void 0)) {
          return null;
        }
        info = this.PATTERN_DATE.exec(str);
        if (!info) {
          return null;
        }
        year = parseInt(info.year, 10);
        month = parseInt(info.month, 10) - 1;
        day = parseInt(info.day, 10);
        if (info.hour == null) {
          date = new Date(Date.UTC(year, month, day));
          return date;
        }
        hour = parseInt(info.hour, 10);
        minute = parseInt(info.minute, 10);
        second = parseInt(info.second, 10);
        if (info.fraction != null) {
          fraction = info.fraction.slice(0, 3);
          while (fraction.length < 3) {
            fraction += "0";
          }
          fraction = parseInt(fraction, 10);
        } else {
          fraction = 0;
        }
        if (info.tz != null) {
          tz_hour = parseInt(info.tz_hour, 10);
          if (info.tz_minute != null) {
            tz_minute = parseInt(info.tz_minute, 10);
          } else {
            tz_minute = 0;
          }
          tz_offset = (tz_hour * 60 + tz_minute) * 6e4;
          if ("-" === info.tz_sign) {
            tz_offset *= -1;
          }
        }
        date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
        if (tz_offset) {
          date.setTime(date.getTime() - tz_offset);
        }
        return date;
      };
      Utils2.strRepeat = function(str, number) {
        var i, res;
        res = "";
        i = 0;
        while (i < number) {
          res += str;
          i++;
        }
        return res;
      };
      Utils2.getStringFromFile = function(path, callback) {
        var data, fs, j, len1, name, ref, req, xhr;
        if (callback == null) {
          callback = null;
        }
        xhr = null;
        if (typeof window !== "undefined" && window !== null) {
          if (window.XMLHttpRequest) {
            xhr = new XMLHttpRequest();
          } else if (window.ActiveXObject) {
            ref = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Msxml2.XMLHTTP", "Microsoft.XMLHTTP"];
            for (j = 0, len1 = ref.length; j < len1; j++) {
              name = ref[j];
              try {
                xhr = new ActiveXObject(name);
              } catch (error) {
              }
            }
          }
        }
        if (xhr != null) {
          if (callback != null) {
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                if (xhr.status === 200 || xhr.status === 0) {
                  return callback(xhr.responseText);
                } else {
                  return callback(null);
                }
              }
            };
            xhr.open("GET", path, true);
            return xhr.send(null);
          } else {
            xhr.open("GET", path, false);
            xhr.send(null);
            if (xhr.status === 200 || xhr.status === 0) {
              return xhr.responseText;
            }
            return null;
          }
        } else {
          req = __require;
          fs = req("fs");
          if (callback != null) {
            return fs.readFile(path, function(err, data2) {
              if (err) {
                return callback(null);
              } else {
                return callback(String(data2));
              }
            });
          } else {
            data = fs.readFileSync(path);
            if (data != null) {
              return String(data);
            }
            return null;
          }
        }
      };
      return Utils2;
    }();
    module.exports = Utils;
  }
});

// node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Unescaper.js
var require_Unescaper = __commonJS({
  "node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Unescaper.js"(exports, module) {
    var Pattern2;
    var Unescaper;
    var Utils;
    Utils = require_Utils();
    Pattern2 = require_Pattern();
    Unescaper = function() {
      function Unescaper2() {
      }
      Unescaper2.PATTERN_ESCAPED_CHARACTER = new Pattern2('\\\\([0abt	nvfre "\\/\\\\N_LP]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})');
      Unescaper2.unescapeSingleQuotedString = function(value) {
        return value.replace(/\'\'/g, "'");
      };
      Unescaper2.unescapeDoubleQuotedString = function(value) {
        if (this._unescapeCallback == null) {
          this._unescapeCallback = function(_this2) {
            return function(str) {
              return _this2.unescapeCharacter(str);
            };
          }(this);
        }
        return this.PATTERN_ESCAPED_CHARACTER.replace(value, this._unescapeCallback);
      };
      Unescaper2.unescapeCharacter = function(value) {
        var ch;
        ch = String.fromCharCode;
        switch (value.charAt(1)) {
          case "0":
            return ch(0);
          case "a":
            return ch(7);
          case "b":
            return ch(8);
          case "t":
            return "	";
          case "	":
            return "	";
          case "n":
            return "\n";
          case "v":
            return ch(11);
          case "f":
            return ch(12);
          case "r":
            return ch(13);
          case "e":
            return ch(27);
          case " ":
            return " ";
          case '"':
            return '"';
          case "/":
            return "/";
          case "\\":
            return "\\";
          case "N":
            return ch(133);
          case "_":
            return ch(160);
          case "L":
            return ch(8232);
          case "P":
            return ch(8233);
          case "x":
            return Utils.utf8chr(Utils.hexDec(value.substr(2, 2)));
          case "u":
            return Utils.utf8chr(Utils.hexDec(value.substr(2, 4)));
          case "U":
            return Utils.utf8chr(Utils.hexDec(value.substr(2, 8)));
          default:
            return "";
        }
      };
      return Unescaper2;
    }();
    module.exports = Unescaper;
  }
});

// node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Escaper.js
var require_Escaper = __commonJS({
  "node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Escaper.js"(exports, module) {
    var Escaper;
    var Pattern2;
    Pattern2 = require_Pattern();
    Escaper = function() {
      var ch;
      function Escaper2() {
      }
      Escaper2.LIST_ESCAPEES = ["\\", "\\\\", '\\"', '"', "\0", "", "", "", "", "", "", "\x07", "\b", "	", "\n", "\v", "\f", "\r", "", "", "", "", "", "", "", "", "", "", "", "", "", "\x1B", "", "", "", "", (ch = String.fromCharCode)(133), ch(160), ch(8232), ch(8233)];
      Escaper2.LIST_ESCAPED = ["\\\\", '\\"', '\\"', '\\"', "\\0", "\\x01", "\\x02", "\\x03", "\\x04", "\\x05", "\\x06", "\\a", "\\b", "\\t", "\\n", "\\v", "\\f", "\\r", "\\x0e", "\\x0f", "\\x10", "\\x11", "\\x12", "\\x13", "\\x14", "\\x15", "\\x16", "\\x17", "\\x18", "\\x19", "\\x1a", "\\e", "\\x1c", "\\x1d", "\\x1e", "\\x1f", "\\N", "\\_", "\\L", "\\P"];
      Escaper2.MAPPING_ESCAPEES_TO_ESCAPED = function() {
        var i, j, mapping, ref;
        mapping = {};
        for (i = j = 0, ref = Escaper2.LIST_ESCAPEES.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          mapping[Escaper2.LIST_ESCAPEES[i]] = Escaper2.LIST_ESCAPED[i];
        }
        return mapping;
      }();
      Escaper2.PATTERN_CHARACTERS_TO_ESCAPE = new Pattern2("[\\x00-\\x1f]|Â|Â |â¨|â©");
      Escaper2.PATTERN_MAPPING_ESCAPEES = new Pattern2(Escaper2.LIST_ESCAPEES.join("|").split("\\").join("\\\\"));
      Escaper2.PATTERN_SINGLE_QUOTING = new Pattern2("[\\s'\":{}[\\],&*#?]|^[-?|<>=!%@`]");
      Escaper2.requiresDoubleQuoting = function(value) {
        return this.PATTERN_CHARACTERS_TO_ESCAPE.test(value);
      };
      Escaper2.escapeWithDoubleQuotes = function(value) {
        var result;
        result = this.PATTERN_MAPPING_ESCAPEES.replace(value, function(_this2) {
          return function(str) {
            return _this2.MAPPING_ESCAPEES_TO_ESCAPED[str];
          };
        }(this));
        return '"' + result + '"';
      };
      Escaper2.requiresSingleQuoting = function(value) {
        return this.PATTERN_SINGLE_QUOTING.test(value);
      };
      Escaper2.escapeWithSingleQuotes = function(value) {
        return "'" + value.replace(/'/g, "''") + "'";
      };
      return Escaper2;
    }();
    module.exports = Escaper;
  }
});

// node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Exception/ParseException.js
var require_ParseException = __commonJS({
  "node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Exception/ParseException.js"(exports, module) {
    var ParseException;
    var extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    var hasProp = {}.hasOwnProperty;
    ParseException = function(superClass) {
      extend(ParseException2, superClass);
      function ParseException2(message, parsedLine, snippet) {
        this.message = message;
        this.parsedLine = parsedLine;
        this.snippet = snippet;
      }
      ParseException2.prototype.toString = function() {
        if (this.parsedLine != null && this.snippet != null) {
          return "<ParseException> " + this.message + " (line " + this.parsedLine + ": '" + this.snippet + "')";
        } else {
          return "<ParseException> " + this.message;
        }
      };
      return ParseException2;
    }(Error);
    module.exports = ParseException;
  }
});

// node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Exception/ParseMore.js
var require_ParseMore = __commonJS({
  "node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Exception/ParseMore.js"(exports, module) {
    var ParseMore;
    var extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    var hasProp = {}.hasOwnProperty;
    ParseMore = function(superClass) {
      extend(ParseMore2, superClass);
      function ParseMore2(message, parsedLine, snippet) {
        this.message = message;
        this.parsedLine = parsedLine;
        this.snippet = snippet;
      }
      ParseMore2.prototype.toString = function() {
        if (this.parsedLine != null && this.snippet != null) {
          return "<ParseMore> " + this.message + " (line " + this.parsedLine + ": '" + this.snippet + "')";
        } else {
          return "<ParseMore> " + this.message;
        }
      };
      return ParseMore2;
    }(Error);
    module.exports = ParseMore;
  }
});

// node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Exception/DumpException.js
var require_DumpException = __commonJS({
  "node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Exception/DumpException.js"(exports, module) {
    var DumpException;
    var extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    var hasProp = {}.hasOwnProperty;
    DumpException = function(superClass) {
      extend(DumpException2, superClass);
      function DumpException2(message, parsedLine, snippet) {
        this.message = message;
        this.parsedLine = parsedLine;
        this.snippet = snippet;
      }
      DumpException2.prototype.toString = function() {
        if (this.parsedLine != null && this.snippet != null) {
          return "<DumpException> " + this.message + " (line " + this.parsedLine + ": '" + this.snippet + "')";
        } else {
          return "<DumpException> " + this.message;
        }
      };
      return DumpException2;
    }(Error);
    module.exports = DumpException;
  }
});

// node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Inline.js
var require_Inline = __commonJS({
  "node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Inline.js"(exports, module) {
    var DumpException;
    var Escaper;
    var Inline;
    var ParseException;
    var ParseMore;
    var Pattern2;
    var Unescaper;
    var Utils;
    var indexOf = [].indexOf || function(item) {
      for (var i = 0, l = this.length; i < l; i++) {
        if (i in this && this[i] === item)
          return i;
      }
      return -1;
    };
    Pattern2 = require_Pattern();
    Unescaper = require_Unescaper();
    Escaper = require_Escaper();
    Utils = require_Utils();
    ParseException = require_ParseException();
    ParseMore = require_ParseMore();
    DumpException = require_DumpException();
    Inline = function() {
      function Inline2() {
      }
      Inline2.REGEX_QUOTED_STRING = `(?:"(?:[^"\\\\]*(?:\\\\.[^"\\\\]*)*)"|'(?:[^']*(?:''[^']*)*)')`;
      Inline2.PATTERN_TRAILING_COMMENTS = new Pattern2("^\\s*#.*$");
      Inline2.PATTERN_QUOTED_SCALAR = new Pattern2("^" + Inline2.REGEX_QUOTED_STRING);
      Inline2.PATTERN_THOUSAND_NUMERIC_SCALAR = new Pattern2("^(-|\\+)?[0-9,]+(\\.[0-9]+)?$");
      Inline2.PATTERN_SCALAR_BY_DELIMITERS = {};
      Inline2.settings = {};
      Inline2.configure = function(exceptionOnInvalidType, objectDecoder) {
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = null;
        }
        if (objectDecoder == null) {
          objectDecoder = null;
        }
        this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
        this.settings.objectDecoder = objectDecoder;
      };
      Inline2.parse = function(value, exceptionOnInvalidType, objectDecoder) {
        var context, result;
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectDecoder == null) {
          objectDecoder = null;
        }
        this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
        this.settings.objectDecoder = objectDecoder;
        if (value == null) {
          return "";
        }
        value = Utils.trim(value);
        if (0 === value.length) {
          return "";
        }
        context = {
          exceptionOnInvalidType,
          objectDecoder,
          i: 0
        };
        switch (value.charAt(0)) {
          case "[":
            result = this.parseSequence(value, context);
            ++context.i;
            break;
          case "{":
            result = this.parseMapping(value, context);
            ++context.i;
            break;
          default:
            result = this.parseScalar(value, null, ['"', "'"], context);
        }
        if (this.PATTERN_TRAILING_COMMENTS.replace(value.slice(context.i), "") !== "") {
          throw new ParseException('Unexpected characters near "' + value.slice(context.i) + '".');
        }
        return result;
      };
      Inline2.dump = function(value, exceptionOnInvalidType, objectEncoder) {
        var ref, result, type;
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectEncoder == null) {
          objectEncoder = null;
        }
        if (value == null) {
          return "null";
        }
        type = typeof value;
        if (type === "object") {
          if (value instanceof Date) {
            return value.toISOString();
          } else if (objectEncoder != null) {
            result = objectEncoder(value);
            if (typeof result === "string" || result != null) {
              return result;
            }
          }
          return this.dumpObject(value);
        }
        if (type === "boolean") {
          return value ? "true" : "false";
        }
        if (Utils.isDigits(value)) {
          return type === "string" ? "'" + value + "'" : String(parseInt(value));
        }
        if (Utils.isNumeric(value)) {
          return type === "string" ? "'" + value + "'" : String(parseFloat(value));
        }
        if (type === "number") {
          return value === Infinity ? ".Inf" : value === -Infinity ? "-.Inf" : isNaN(value) ? ".NaN" : value;
        }
        if (Escaper.requiresDoubleQuoting(value)) {
          return Escaper.escapeWithDoubleQuotes(value);
        }
        if (Escaper.requiresSingleQuoting(value)) {
          return Escaper.escapeWithSingleQuotes(value);
        }
        if ("" === value) {
          return '""';
        }
        if (Utils.PATTERN_DATE.test(value)) {
          return "'" + value + "'";
        }
        if ((ref = value.toLowerCase()) === "null" || ref === "~" || ref === "true" || ref === "false") {
          return "'" + value + "'";
        }
        return value;
      };
      Inline2.dumpObject = function(value, exceptionOnInvalidType, objectSupport) {
        var j, key, len1, output, val;
        if (objectSupport == null) {
          objectSupport = null;
        }
        if (value instanceof Array) {
          output = [];
          for (j = 0, len1 = value.length; j < len1; j++) {
            val = value[j];
            output.push(this.dump(val));
          }
          return "[" + output.join(", ") + "]";
        } else {
          output = [];
          for (key in value) {
            val = value[key];
            output.push(this.dump(key) + ": " + this.dump(val));
          }
          return "{" + output.join(", ") + "}";
        }
      };
      Inline2.parseScalar = function(scalar, delimiters, stringDelimiters, context, evaluate) {
        var i, joinedDelimiters, match, output, pattern, ref, ref1, strpos, tmp;
        if (delimiters == null) {
          delimiters = null;
        }
        if (stringDelimiters == null) {
          stringDelimiters = ['"', "'"];
        }
        if (context == null) {
          context = null;
        }
        if (evaluate == null) {
          evaluate = true;
        }
        if (context == null) {
          context = {
            exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
            objectDecoder: this.settings.objectDecoder,
            i: 0
          };
        }
        i = context.i;
        if (ref = scalar.charAt(i), indexOf.call(stringDelimiters, ref) >= 0) {
          output = this.parseQuotedScalar(scalar, context);
          i = context.i;
          if (delimiters != null) {
            tmp = Utils.ltrim(scalar.slice(i), " ");
            if (!(ref1 = tmp.charAt(0), indexOf.call(delimiters, ref1) >= 0)) {
              throw new ParseException("Unexpected characters (" + scalar.slice(i) + ").");
            }
          }
        } else {
          if (!delimiters) {
            output = scalar.slice(i);
            i += output.length;
            strpos = output.indexOf(" #");
            if (strpos !== -1) {
              output = Utils.rtrim(output.slice(0, strpos));
            }
          } else {
            joinedDelimiters = delimiters.join("|");
            pattern = this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters];
            if (pattern == null) {
              pattern = new Pattern2("^(.+?)(" + joinedDelimiters + ")");
              this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters] = pattern;
            }
            if (match = pattern.exec(scalar.slice(i))) {
              output = match[1];
              i += output.length;
            } else {
              throw new ParseException("Malformed inline YAML string (" + scalar + ").");
            }
          }
          if (evaluate) {
            output = this.evaluateScalar(output, context);
          }
        }
        context.i = i;
        return output;
      };
      Inline2.parseQuotedScalar = function(scalar, context) {
        var i, match, output;
        i = context.i;
        if (!(match = this.PATTERN_QUOTED_SCALAR.exec(scalar.slice(i)))) {
          throw new ParseMore("Malformed inline YAML string (" + scalar.slice(i) + ").");
        }
        output = match[0].substr(1, match[0].length - 2);
        if ('"' === scalar.charAt(i)) {
          output = Unescaper.unescapeDoubleQuotedString(output);
        } else {
          output = Unescaper.unescapeSingleQuotedString(output);
        }
        i += match[0].length;
        context.i = i;
        return output;
      };
      Inline2.parseSequence = function(sequence, context) {
        var e, i, isQuoted, len, output, ref, value;
        output = [];
        len = sequence.length;
        i = context.i;
        i += 1;
        while (i < len) {
          context.i = i;
          switch (sequence.charAt(i)) {
            case "[":
              output.push(this.parseSequence(sequence, context));
              i = context.i;
              break;
            case "{":
              output.push(this.parseMapping(sequence, context));
              i = context.i;
              break;
            case "]":
              return output;
            case ",":
            case " ":
            case "\n":
              break;
            default:
              isQuoted = (ref = sequence.charAt(i)) === '"' || ref === "'";
              value = this.parseScalar(sequence, [",", "]"], ['"', "'"], context);
              i = context.i;
              if (!isQuoted && typeof value === "string" && (value.indexOf(": ") !== -1 || value.indexOf(":\n") !== -1)) {
                try {
                  value = this.parseMapping("{" + value + "}");
                } catch (error) {
                  e = error;
                }
              }
              output.push(value);
              --i;
          }
          ++i;
        }
        throw new ParseMore("Malformed inline YAML string " + sequence);
      };
      Inline2.parseMapping = function(mapping, context) {
        var done, i, key, len, output, shouldContinueWhileLoop, value;
        output = {};
        len = mapping.length;
        i = context.i;
        i += 1;
        shouldContinueWhileLoop = false;
        while (i < len) {
          context.i = i;
          switch (mapping.charAt(i)) {
            case " ":
            case ",":
            case "\n":
              ++i;
              context.i = i;
              shouldContinueWhileLoop = true;
              break;
            case "}":
              return output;
          }
          if (shouldContinueWhileLoop) {
            shouldContinueWhileLoop = false;
            continue;
          }
          key = this.parseScalar(mapping, [":", " ", "\n"], ['"', "'"], context, false);
          i = context.i;
          done = false;
          while (i < len) {
            context.i = i;
            switch (mapping.charAt(i)) {
              case "[":
                value = this.parseSequence(mapping, context);
                i = context.i;
                if (output[key] === void 0) {
                  output[key] = value;
                }
                done = true;
                break;
              case "{":
                value = this.parseMapping(mapping, context);
                i = context.i;
                if (output[key] === void 0) {
                  output[key] = value;
                }
                done = true;
                break;
              case ":":
              case " ":
              case "\n":
                break;
              default:
                value = this.parseScalar(mapping, [",", "}"], ['"', "'"], context);
                i = context.i;
                if (output[key] === void 0) {
                  output[key] = value;
                }
                done = true;
                --i;
            }
            ++i;
            if (done) {
              break;
            }
          }
        }
        throw new ParseMore("Malformed inline YAML string " + mapping);
      };
      Inline2.evaluateScalar = function(scalar, context) {
        var cast, date, exceptionOnInvalidType, firstChar, firstSpace, firstWord, objectDecoder, raw, scalarLower, subValue, trimmedScalar;
        scalar = Utils.trim(scalar);
        scalarLower = scalar.toLowerCase();
        switch (scalarLower) {
          case "null":
          case "":
          case "~":
            return null;
          case "true":
            return true;
          case "false":
            return false;
          case ".inf":
            return Infinity;
          case ".nan":
            return 0 / 0;
          case "-.inf":
            return Infinity;
          default:
            firstChar = scalarLower.charAt(0);
            switch (firstChar) {
              case "!":
                firstSpace = scalar.indexOf(" ");
                if (firstSpace === -1) {
                  firstWord = scalarLower;
                } else {
                  firstWord = scalarLower.slice(0, firstSpace);
                }
                switch (firstWord) {
                  case "!":
                    if (firstSpace !== -1) {
                      return parseInt(this.parseScalar(scalar.slice(2)));
                    }
                    return null;
                  case "!str":
                    return Utils.ltrim(scalar.slice(4));
                  case "!!str":
                    return Utils.ltrim(scalar.slice(5));
                  case "!!int":
                    return parseInt(this.parseScalar(scalar.slice(5)));
                  case "!!bool":
                    return Utils.parseBoolean(this.parseScalar(scalar.slice(6)), false);
                  case "!!float":
                    return parseFloat(this.parseScalar(scalar.slice(7)));
                  case "!!timestamp":
                    return Utils.stringToDate(Utils.ltrim(scalar.slice(11)));
                  default:
                    if (context == null) {
                      context = {
                        exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
                        objectDecoder: this.settings.objectDecoder,
                        i: 0
                      };
                    }
                    objectDecoder = context.objectDecoder, exceptionOnInvalidType = context.exceptionOnInvalidType;
                    if (objectDecoder) {
                      trimmedScalar = Utils.rtrim(scalar);
                      firstSpace = trimmedScalar.indexOf(" ");
                      if (firstSpace === -1) {
                        return objectDecoder(trimmedScalar, null);
                      } else {
                        subValue = Utils.ltrim(trimmedScalar.slice(firstSpace + 1));
                        if (!(subValue.length > 0)) {
                          subValue = null;
                        }
                        return objectDecoder(trimmedScalar.slice(0, firstSpace), subValue);
                      }
                    }
                    if (exceptionOnInvalidType) {
                      throw new ParseException("Custom object support when parsing a YAML file has been disabled.");
                    }
                    return null;
                }
                break;
              case "0":
                if ("0x" === scalar.slice(0, 2)) {
                  return Utils.hexDec(scalar);
                } else if (Utils.isDigits(scalar)) {
                  return Utils.octDec(scalar);
                } else if (Utils.isNumeric(scalar)) {
                  return parseFloat(scalar);
                } else {
                  return scalar;
                }
                break;
              case "+":
                if (Utils.isDigits(scalar)) {
                  raw = scalar;
                  cast = parseInt(raw);
                  if (raw === String(cast)) {
                    return cast;
                  } else {
                    return raw;
                  }
                } else if (Utils.isNumeric(scalar)) {
                  return parseFloat(scalar);
                } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
                  return parseFloat(scalar.replace(",", ""));
                }
                return scalar;
              case "-":
                if (Utils.isDigits(scalar.slice(1))) {
                  if ("0" === scalar.charAt(1)) {
                    return -Utils.octDec(scalar.slice(1));
                  } else {
                    raw = scalar.slice(1);
                    cast = parseInt(raw);
                    if (raw === String(cast)) {
                      return -cast;
                    } else {
                      return -raw;
                    }
                  }
                } else if (Utils.isNumeric(scalar)) {
                  return parseFloat(scalar);
                } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
                  return parseFloat(scalar.replace(",", ""));
                }
                return scalar;
              default:
                if (date = Utils.stringToDate(scalar)) {
                  return date;
                } else if (Utils.isNumeric(scalar)) {
                  return parseFloat(scalar);
                } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
                  return parseFloat(scalar.replace(",", ""));
                }
                return scalar;
            }
        }
      };
      return Inline2;
    }();
    module.exports = Inline;
  }
});

// node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Parser.js
var require_Parser = __commonJS({
  "node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Parser.js"(exports, module) {
    var Inline;
    var ParseException;
    var ParseMore;
    var Parser;
    var Pattern2;
    var Utils;
    Inline = require_Inline();
    Pattern2 = require_Pattern();
    Utils = require_Utils();
    ParseException = require_ParseException();
    ParseMore = require_ParseMore();
    Parser = function() {
      Parser2.prototype.PATTERN_FOLDED_SCALAR_ALL = new Pattern2("^(?:(?<type>![^\\|>]*)\\s+)?(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$");
      Parser2.prototype.PATTERN_FOLDED_SCALAR_END = new Pattern2("(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$");
      Parser2.prototype.PATTERN_SEQUENCE_ITEM = new Pattern2("^\\-((?<leadspaces>\\s+)(?<value>.+?))?\\s*$");
      Parser2.prototype.PATTERN_ANCHOR_VALUE = new Pattern2("^&(?<ref>[^ ]+) *(?<value>.*)");
      Parser2.prototype.PATTERN_COMPACT_NOTATION = new Pattern2("^(?<key>" + Inline.REGEX_QUOTED_STRING + `|[^ '"\\{\\[].*?) *\\:(\\s+(?<value>.+?))?\\s*$`);
      Parser2.prototype.PATTERN_MAPPING_ITEM = new Pattern2("^(?<key>" + Inline.REGEX_QUOTED_STRING + `|[^ '"\\[\\{].*?) *\\:(\\s+(?<value>.+?))?\\s*$`);
      Parser2.prototype.PATTERN_DECIMAL = new Pattern2("\\d+");
      Parser2.prototype.PATTERN_INDENT_SPACES = new Pattern2("^ +");
      Parser2.prototype.PATTERN_TRAILING_LINES = new Pattern2("(\n*)$");
      Parser2.prototype.PATTERN_YAML_HEADER = new Pattern2("^\\%YAML[: ][\\d\\.]+.*\n", "m");
      Parser2.prototype.PATTERN_LEADING_COMMENTS = new Pattern2("^(\\#.*?\n)+", "m");
      Parser2.prototype.PATTERN_DOCUMENT_MARKER_START = new Pattern2("^\\-\\-\\-.*?\n", "m");
      Parser2.prototype.PATTERN_DOCUMENT_MARKER_END = new Pattern2("^\\.\\.\\.\\s*$", "m");
      Parser2.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION = {};
      Parser2.prototype.CONTEXT_NONE = 0;
      Parser2.prototype.CONTEXT_SEQUENCE = 1;
      Parser2.prototype.CONTEXT_MAPPING = 2;
      function Parser2(offset) {
        this.offset = offset != null ? offset : 0;
        this.lines = [];
        this.currentLineNb = -1;
        this.currentLine = "";
        this.refs = {};
      }
      Parser2.prototype.parse = function(value, exceptionOnInvalidType, objectDecoder) {
        var alias, allowOverwrite, block, c, context, data, e, first, i, indent, isRef, j, k, key, l, lastKey, len, len1, len2, len3, lineCount, m, matches, mergeNode, n, name, parsed, parsedItem, parser, ref, ref1, ref2, refName, refValue, val, values;
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectDecoder == null) {
          objectDecoder = null;
        }
        this.currentLineNb = -1;
        this.currentLine = "";
        this.lines = this.cleanup(value).split("\n");
        data = null;
        context = this.CONTEXT_NONE;
        allowOverwrite = false;
        while (this.moveToNextLine()) {
          if (this.isCurrentLineEmpty()) {
            continue;
          }
          if ("	" === this.currentLine[0]) {
            throw new ParseException("A YAML file cannot contain tabs as indentation.", this.getRealCurrentLineNb() + 1, this.currentLine);
          }
          isRef = mergeNode = false;
          if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {
            if (this.CONTEXT_MAPPING === context) {
              throw new ParseException("You cannot define a sequence item when in a mapping");
            }
            context = this.CONTEXT_SEQUENCE;
            if (data == null) {
              data = [];
            }
            if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
              isRef = matches.ref;
              values.value = matches.value;
            }
            if (!(values.value != null) || "" === Utils.trim(values.value, " ") || Utils.ltrim(values.value, " ").indexOf("#") === 0) {
              if (this.currentLineNb < this.lines.length - 1 && !this.isNextLineUnIndentedCollection()) {
                c = this.getRealCurrentLineNb() + 1;
                parser = new Parser2(c);
                parser.refs = this.refs;
                data.push(parser.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));
              } else {
                data.push(null);
              }
            } else {
              if (((ref = values.leadspaces) != null ? ref.length : void 0) && (matches = this.PATTERN_COMPACT_NOTATION.exec(values.value))) {
                c = this.getRealCurrentLineNb();
                parser = new Parser2(c);
                parser.refs = this.refs;
                block = values.value;
                indent = this.getCurrentLineIndentation();
                if (this.isNextLineIndented(false)) {
                  block += "\n" + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);
                }
                data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));
              } else {
                data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));
              }
            }
          } else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) && values.key.indexOf(" #") === -1) {
            if (this.CONTEXT_SEQUENCE === context) {
              throw new ParseException("You cannot define a mapping item when in a sequence");
            }
            context = this.CONTEXT_MAPPING;
            if (data == null) {
              data = {};
            }
            Inline.configure(exceptionOnInvalidType, objectDecoder);
            try {
              key = Inline.parseScalar(values.key);
            } catch (error) {
              e = error;
              e.parsedLine = this.getRealCurrentLineNb() + 1;
              e.snippet = this.currentLine;
              throw e;
            }
            if ("<<" === key) {
              mergeNode = true;
              allowOverwrite = true;
              if (((ref1 = values.value) != null ? ref1.indexOf("*") : void 0) === 0) {
                refName = values.value.slice(1);
                if (this.refs[refName] == null) {
                  throw new ParseException('Reference "' + refName + '" does not exist.', this.getRealCurrentLineNb() + 1, this.currentLine);
                }
                refValue = this.refs[refName];
                if (typeof refValue !== "object") {
                  throw new ParseException("YAML merge keys used with a scalar value instead of an object.", this.getRealCurrentLineNb() + 1, this.currentLine);
                }
                if (refValue instanceof Array) {
                  for (i = j = 0, len = refValue.length; j < len; i = ++j) {
                    value = refValue[i];
                    if (data[name = String(i)] == null) {
                      data[name] = value;
                    }
                  }
                } else {
                  for (key in refValue) {
                    value = refValue[key];
                    if (data[key] == null) {
                      data[key] = value;
                    }
                  }
                }
              } else {
                if (values.value != null && values.value !== "") {
                  value = values.value;
                } else {
                  value = this.getNextEmbedBlock();
                }
                c = this.getRealCurrentLineNb() + 1;
                parser = new Parser2(c);
                parser.refs = this.refs;
                parsed = parser.parse(value, exceptionOnInvalidType);
                if (typeof parsed !== "object") {
                  throw new ParseException("YAML merge keys used with a scalar value instead of an object.", this.getRealCurrentLineNb() + 1, this.currentLine);
                }
                if (parsed instanceof Array) {
                  for (l = 0, len1 = parsed.length; l < len1; l++) {
                    parsedItem = parsed[l];
                    if (typeof parsedItem !== "object") {
                      throw new ParseException("Merge items must be objects.", this.getRealCurrentLineNb() + 1, parsedItem);
                    }
                    if (parsedItem instanceof Array) {
                      for (i = m = 0, len2 = parsedItem.length; m < len2; i = ++m) {
                        value = parsedItem[i];
                        k = String(i);
                        if (!data.hasOwnProperty(k)) {
                          data[k] = value;
                        }
                      }
                    } else {
                      for (key in parsedItem) {
                        value = parsedItem[key];
                        if (!data.hasOwnProperty(key)) {
                          data[key] = value;
                        }
                      }
                    }
                  }
                } else {
                  for (key in parsed) {
                    value = parsed[key];
                    if (!data.hasOwnProperty(key)) {
                      data[key] = value;
                    }
                  }
                }
              }
            } else if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
              isRef = matches.ref;
              values.value = matches.value;
            }
            if (mergeNode) {
            } else if (!(values.value != null) || "" === Utils.trim(values.value, " ") || Utils.ltrim(values.value, " ").indexOf("#") === 0) {
              if (!this.isNextLineIndented() && !this.isNextLineUnIndentedCollection()) {
                if (allowOverwrite || data[key] === void 0) {
                  data[key] = null;
                }
              } else {
                c = this.getRealCurrentLineNb() + 1;
                parser = new Parser2(c);
                parser.refs = this.refs;
                val = parser.parse(this.getNextEmbedBlock(), exceptionOnInvalidType, objectDecoder);
                if (allowOverwrite || data[key] === void 0) {
                  data[key] = val;
                }
              }
            } else {
              val = this.parseValue(values.value, exceptionOnInvalidType, objectDecoder);
              if (allowOverwrite || data[key] === void 0) {
                data[key] = val;
              }
            }
          } else {
            lineCount = this.lines.length;
            if (1 === lineCount || 2 === lineCount && Utils.isEmpty(this.lines[1])) {
              try {
                value = Inline.parse(this.lines[0], exceptionOnInvalidType, objectDecoder);
              } catch (error) {
                e = error;
                e.parsedLine = this.getRealCurrentLineNb() + 1;
                e.snippet = this.currentLine;
                throw e;
              }
              if (typeof value === "object") {
                if (value instanceof Array) {
                  first = value[0];
                } else {
                  for (key in value) {
                    first = value[key];
                    break;
                  }
                }
                if (typeof first === "string" && first.indexOf("*") === 0) {
                  data = [];
                  for (n = 0, len3 = value.length; n < len3; n++) {
                    alias = value[n];
                    data.push(this.refs[alias.slice(1)]);
                  }
                  value = data;
                }
              }
              return value;
            } else if ((ref2 = Utils.ltrim(value).charAt(0)) === "[" || ref2 === "{") {
              try {
                return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
              } catch (error) {
                e = error;
                e.parsedLine = this.getRealCurrentLineNb() + 1;
                e.snippet = this.currentLine;
                throw e;
              }
            }
            throw new ParseException("Unable to parse.", this.getRealCurrentLineNb() + 1, this.currentLine);
          }
          if (isRef) {
            if (data instanceof Array) {
              this.refs[isRef] = data[data.length - 1];
            } else {
              lastKey = null;
              for (key in data) {
                lastKey = key;
              }
              this.refs[isRef] = data[lastKey];
            }
          }
        }
        if (Utils.isEmpty(data)) {
          return null;
        } else {
          return data;
        }
      };
      Parser2.prototype.getRealCurrentLineNb = function() {
        return this.currentLineNb + this.offset;
      };
      Parser2.prototype.getCurrentLineIndentation = function() {
        return this.currentLine.length - Utils.ltrim(this.currentLine, " ").length;
      };
      Parser2.prototype.getNextEmbedBlock = function(indentation, includeUnindentedCollection) {
        var data, indent, isItUnindentedCollection, newIndent, removeComments, removeCommentsPattern, unindentedEmbedBlock;
        if (indentation == null) {
          indentation = null;
        }
        if (includeUnindentedCollection == null) {
          includeUnindentedCollection = false;
        }
        this.moveToNextLine();
        if (indentation == null) {
          newIndent = this.getCurrentLineIndentation();
          unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);
          if (!this.isCurrentLineEmpty() && 0 === newIndent && !unindentedEmbedBlock) {
            throw new ParseException("Indentation problem.", this.getRealCurrentLineNb() + 1, this.currentLine);
          }
        } else {
          newIndent = indentation;
        }
        data = [this.currentLine.slice(newIndent)];
        if (!includeUnindentedCollection) {
          isItUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);
        }
        removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;
        removeComments = !removeCommentsPattern.test(this.currentLine);
        while (this.moveToNextLine()) {
          indent = this.getCurrentLineIndentation();
          if (indent === newIndent) {
            removeComments = !removeCommentsPattern.test(this.currentLine);
          }
          if (removeComments && this.isCurrentLineComment()) {
            continue;
          }
          if (this.isCurrentLineBlank()) {
            data.push(this.currentLine.slice(newIndent));
            continue;
          }
          if (isItUnindentedCollection && !this.isStringUnIndentedCollectionItem(this.currentLine) && indent === newIndent) {
            this.moveToPreviousLine();
            break;
          }
          if (indent >= newIndent) {
            data.push(this.currentLine.slice(newIndent));
          } else if (Utils.ltrim(this.currentLine).charAt(0) === "#") {
          } else if (0 === indent) {
            this.moveToPreviousLine();
            break;
          } else {
            throw new ParseException("Indentation problem.", this.getRealCurrentLineNb() + 1, this.currentLine);
          }
        }
        return data.join("\n");
      };
      Parser2.prototype.moveToNextLine = function() {
        if (this.currentLineNb >= this.lines.length - 1) {
          return false;
        }
        this.currentLine = this.lines[++this.currentLineNb];
        return true;
      };
      Parser2.prototype.moveToPreviousLine = function() {
        this.currentLine = this.lines[--this.currentLineNb];
      };
      Parser2.prototype.parseValue = function(value, exceptionOnInvalidType, objectDecoder) {
        var e, foldedIndent, matches, modifiers, pos, ref, ref1, val;
        if (0 === value.indexOf("*")) {
          pos = value.indexOf("#");
          if (pos !== -1) {
            value = value.substr(1, pos - 2);
          } else {
            value = value.slice(1);
          }
          if (this.refs[value] === void 0) {
            throw new ParseException('Reference "' + value + '" does not exist.', this.currentLine);
          }
          return this.refs[value];
        }
        if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {
          modifiers = (ref = matches.modifiers) != null ? ref : "";
          foldedIndent = Math.abs(parseInt(modifiers));
          if (isNaN(foldedIndent)) {
            foldedIndent = 0;
          }
          val = this.parseFoldedScalar(matches.separator, this.PATTERN_DECIMAL.replace(modifiers, ""), foldedIndent);
          if (matches.type != null) {
            Inline.configure(exceptionOnInvalidType, objectDecoder);
            return Inline.parseScalar(matches.type + " " + val);
          } else {
            return val;
          }
        }
        if ((ref1 = value.charAt(0)) === "[" || ref1 === "{" || ref1 === '"' || ref1 === "'") {
          while (true) {
            try {
              return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
            } catch (error) {
              e = error;
              if (e instanceof ParseMore && this.moveToNextLine()) {
                value += "\n" + Utils.trim(this.currentLine, " ");
              } else {
                e.parsedLine = this.getRealCurrentLineNb() + 1;
                e.snippet = this.currentLine;
                throw e;
              }
            }
          }
        } else {
          if (this.isNextLineIndented()) {
            value += "\n" + this.getNextEmbedBlock();
          }
          return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
        }
      };
      Parser2.prototype.parseFoldedScalar = function(separator, indicator, indentation) {
        var isCurrentLineBlank, j, len, line, matches, newText, notEOF, pattern, ref, text;
        if (indicator == null) {
          indicator = "";
        }
        if (indentation == null) {
          indentation = 0;
        }
        notEOF = this.moveToNextLine();
        if (!notEOF) {
          return "";
        }
        isCurrentLineBlank = this.isCurrentLineBlank();
        text = "";
        while (notEOF && isCurrentLineBlank) {
          if (notEOF = this.moveToNextLine()) {
            text += "\n";
            isCurrentLineBlank = this.isCurrentLineBlank();
          }
        }
        if (0 === indentation) {
          if (matches = this.PATTERN_INDENT_SPACES.exec(this.currentLine)) {
            indentation = matches[0].length;
          }
        }
        if (indentation > 0) {
          pattern = this.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation];
          if (pattern == null) {
            pattern = new Pattern2("^ {" + indentation + "}(.*)$");
            Parser2.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation] = pattern;
          }
          while (notEOF && (isCurrentLineBlank || (matches = pattern.exec(this.currentLine)))) {
            if (isCurrentLineBlank) {
              text += this.currentLine.slice(indentation);
            } else {
              text += matches[1];
            }
            if (notEOF = this.moveToNextLine()) {
              text += "\n";
              isCurrentLineBlank = this.isCurrentLineBlank();
            }
          }
        } else if (notEOF) {
          text += "\n";
        }
        if (notEOF) {
          this.moveToPreviousLine();
        }
        if (">" === separator) {
          newText = "";
          ref = text.split("\n");
          for (j = 0, len = ref.length; j < len; j++) {
            line = ref[j];
            if (line.length === 0 || line.charAt(0) === " ") {
              newText = Utils.rtrim(newText, " ") + line + "\n";
            } else {
              newText += line + " ";
            }
          }
          text = newText;
        }
        if ("+" !== indicator) {
          text = Utils.rtrim(text);
        }
        if ("" === indicator) {
          text = this.PATTERN_TRAILING_LINES.replace(text, "\n");
        } else if ("-" === indicator) {
          text = this.PATTERN_TRAILING_LINES.replace(text, "");
        }
        return text;
      };
      Parser2.prototype.isNextLineIndented = function(ignoreComments) {
        var EOF, currentIndentation, ret;
        if (ignoreComments == null) {
          ignoreComments = true;
        }
        currentIndentation = this.getCurrentLineIndentation();
        EOF = !this.moveToNextLine();
        if (ignoreComments) {
          while (!EOF && this.isCurrentLineEmpty()) {
            EOF = !this.moveToNextLine();
          }
        } else {
          while (!EOF && this.isCurrentLineBlank()) {
            EOF = !this.moveToNextLine();
          }
        }
        if (EOF) {
          return false;
        }
        ret = false;
        if (this.getCurrentLineIndentation() > currentIndentation) {
          ret = true;
        }
        this.moveToPreviousLine();
        return ret;
      };
      Parser2.prototype.isCurrentLineEmpty = function() {
        var trimmedLine;
        trimmedLine = Utils.trim(this.currentLine, " ");
        return trimmedLine.length === 0 || trimmedLine.charAt(0) === "#";
      };
      Parser2.prototype.isCurrentLineBlank = function() {
        return "" === Utils.trim(this.currentLine, " ");
      };
      Parser2.prototype.isCurrentLineComment = function() {
        var ltrimmedLine;
        ltrimmedLine = Utils.ltrim(this.currentLine, " ");
        return ltrimmedLine.charAt(0) === "#";
      };
      Parser2.prototype.cleanup = function(value) {
        var count, i, indent, j, l, len, len1, line, lines, ref, ref1, ref2, smallestIndent, trimmedValue;
        if (value.indexOf("\r") !== -1) {
          value = value.split("\r\n").join("\n").split("\r").join("\n");
        }
        count = 0;
        ref = this.PATTERN_YAML_HEADER.replaceAll(value, ""), value = ref[0], count = ref[1];
        this.offset += count;
        ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, "", 1), trimmedValue = ref1[0], count = ref1[1];
        if (count === 1) {
          this.offset += Utils.subStrCount(value, "\n") - Utils.subStrCount(trimmedValue, "\n");
          value = trimmedValue;
        }
        ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, "", 1), trimmedValue = ref2[0], count = ref2[1];
        if (count === 1) {
          this.offset += Utils.subStrCount(value, "\n") - Utils.subStrCount(trimmedValue, "\n");
          value = trimmedValue;
          value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, "");
        }
        lines = value.split("\n");
        smallestIndent = -1;
        for (j = 0, len = lines.length; j < len; j++) {
          line = lines[j];
          if (Utils.trim(line, " ").length === 0) {
            continue;
          }
          indent = line.length - Utils.ltrim(line).length;
          if (smallestIndent === -1 || indent < smallestIndent) {
            smallestIndent = indent;
          }
        }
        if (smallestIndent > 0) {
          for (i = l = 0, len1 = lines.length; l < len1; i = ++l) {
            line = lines[i];
            lines[i] = line.slice(smallestIndent);
          }
          value = lines.join("\n");
        }
        return value;
      };
      Parser2.prototype.isNextLineUnIndentedCollection = function(currentIndentation) {
        var notEOF, ret;
        if (currentIndentation == null) {
          currentIndentation = null;
        }
        if (currentIndentation == null) {
          currentIndentation = this.getCurrentLineIndentation();
        }
        notEOF = this.moveToNextLine();
        while (notEOF && this.isCurrentLineEmpty()) {
          notEOF = this.moveToNextLine();
        }
        if (false === notEOF) {
          return false;
        }
        ret = false;
        if (this.getCurrentLineIndentation() === currentIndentation && this.isStringUnIndentedCollectionItem(this.currentLine)) {
          ret = true;
        }
        this.moveToPreviousLine();
        return ret;
      };
      Parser2.prototype.isStringUnIndentedCollectionItem = function() {
        return this.currentLine === "-" || this.currentLine.slice(0, 2) === "- ";
      };
      return Parser2;
    }();
    module.exports = Parser;
  }
});

// node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Dumper.js
var require_Dumper = __commonJS({
  "node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Dumper.js"(exports, module) {
    var Dumper;
    var Inline;
    var Utils;
    Utils = require_Utils();
    Inline = require_Inline();
    Dumper = function() {
      function Dumper2() {
      }
      Dumper2.indentation = 4;
      Dumper2.prototype.dump = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
        var i, key, len, output, prefix, value, willBeInlined;
        if (inline == null) {
          inline = 0;
        }
        if (indent == null) {
          indent = 0;
        }
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectEncoder == null) {
          objectEncoder = null;
        }
        output = "";
        prefix = indent ? Utils.strRepeat(" ", indent) : "";
        if (inline <= 0 || typeof input !== "object" || input instanceof Date || Utils.isEmpty(input)) {
          output += prefix + Inline.dump(input, exceptionOnInvalidType, objectEncoder);
        } else {
          if (input instanceof Array) {
            for (i = 0, len = input.length; i < len; i++) {
              value = input[i];
              willBeInlined = inline - 1 <= 0 || typeof value !== "object" || Utils.isEmpty(value);
              output += prefix + "-" + (willBeInlined ? " " : "\n") + this.dump(value, inline - 1, willBeInlined ? 0 : indent + this.indentation, exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : "");
            }
          } else {
            for (key in input) {
              value = input[key];
              willBeInlined = inline - 1 <= 0 || typeof value !== "object" || Utils.isEmpty(value);
              output += prefix + Inline.dump(key, exceptionOnInvalidType, objectEncoder) + ":" + (willBeInlined ? " " : "\n") + this.dump(value, inline - 1, willBeInlined ? 0 : indent + this.indentation, exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : "");
            }
          }
        }
        return output;
      };
      return Dumper2;
    }();
    module.exports = Dumper;
  }
});

// node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Yaml.js
var require_Yaml = __commonJS({
  "node_modules/.pnpm/yamljs@0.3.0/node_modules/yamljs/lib/Yaml.js"(exports, module) {
    var Dumper;
    var Parser;
    var Utils;
    var Yaml;
    Parser = require_Parser();
    Dumper = require_Dumper();
    Utils = require_Utils();
    Yaml = function() {
      function Yaml2() {
      }
      Yaml2.parse = function(input, exceptionOnInvalidType, objectDecoder) {
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectDecoder == null) {
          objectDecoder = null;
        }
        return new Parser().parse(input, exceptionOnInvalidType, objectDecoder);
      };
      Yaml2.parseFile = function(path, callback, exceptionOnInvalidType, objectDecoder) {
        var input;
        if (callback == null) {
          callback = null;
        }
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectDecoder == null) {
          objectDecoder = null;
        }
        if (callback != null) {
          return Utils.getStringFromFile(path, function(_this2) {
            return function(input2) {
              var result;
              result = null;
              if (input2 != null) {
                result = _this2.parse(input2, exceptionOnInvalidType, objectDecoder);
              }
              callback(result);
            };
          }(this));
        } else {
          input = Utils.getStringFromFile(path);
          if (input != null) {
            return this.parse(input, exceptionOnInvalidType, objectDecoder);
          }
          return null;
        }
      };
      Yaml2.dump = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
        var yaml;
        if (inline == null) {
          inline = 2;
        }
        if (indent == null) {
          indent = 4;
        }
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectEncoder == null) {
          objectEncoder = null;
        }
        yaml = new Dumper();
        yaml.indentation = indent;
        return yaml.dump(input, inline, 0, exceptionOnInvalidType, objectEncoder);
      };
      Yaml2.stringify = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
        return this.dump(input, inline, indent, exceptionOnInvalidType, objectEncoder);
      };
      Yaml2.load = function(path, callback, exceptionOnInvalidType, objectDecoder) {
        return this.parseFile(path, callback, exceptionOnInvalidType, objectDecoder);
      };
      return Yaml2;
    }();
    if (typeof window !== "undefined" && window !== null) {
      window.YAML = Yaml;
    }
    if (typeof window === "undefined" || window === null) {
      exports.YAML = Yaml;
    }
    module.exports = Yaml;
  }
});

// node_modules/.pnpm/composerize-ts@0.6.2/node_modules/composerize-ts/dist/esm/parser.js
var import_flex_js = __toESM(require_flex_js());

// node_modules/.pnpm/composerize-ts@0.6.2/node_modules/composerize-ts/dist/esm/types.js
var ComposerizeResult = (
  /** @class */
  function() {
    function ComposerizeResult2(yaml, messages) {
      this.yaml = yaml;
      this.messages = messages;
    }
    return ComposerizeResult2;
  }()
);
var SupportedOption = (
  /** @class */
  function() {
    function SupportedOption2(dockerOption, composeEquivalent, shortOption) {
      this.dockerOption = dockerOption;
      this.composeEquivalent = composeEquivalent;
      if (shortOption !== void 0) {
        this.dockerOption += "/" + shortOption;
      }
    }
    return SupportedOption2;
  }()
);
var MessageType;
(function(MessageType2) {
  MessageType2["notImplemented"] = "notImplemented";
  MessageType2["notTranslatable"] = "notTranslatable";
  MessageType2["errorDuringConversion"] = "errorDuringConversion";
})(MessageType || (MessageType = {}));
var ParseResult = (
  /** @class */
  function() {
    function ParseResult2() {
      this.serviceName = "";
      this.properties = [];
      this.messages = [];
      this.additionalComposeObjects = [];
    }
    return ParseResult2;
  }()
);
var OptionType;
(function(OptionType2) {
  OptionType2[OptionType2["flag"] = 0] = "flag";
  OptionType2[OptionType2["withArgs"] = 1] = "withArgs";
})(OptionType || (OptionType = {}));

// node_modules/.pnpm/composerize-ts@0.6.2/node_modules/composerize-ts/dist/esm/callbacks.js
var import_set_value = __toESM(require_set_value());
var getValue = function(value, opt) {
  if (typeof value === "string") {
    if (opt.multiValue) {
      if (opt.composeType !== void 0 && /^\-?\d+$/.test(value)) {
        try {
          return opt.composeType === "int" ? [parseInt(value)] : [parseFloat(value)];
        } catch (e) {
          return [value];
        }
      }
      return [value];
    }
    if (opt.composeType !== void 0 && /^\-?\d+$/.test(value)) {
      try {
        return opt.composeType === "int" ? parseInt(value) : parseFloat(value);
      } catch (e) {
        return value;
      }
    }
  }
  return value;
};
var notYetImplemented = function(opt) {
  return {
    type: MessageType.notImplemented,
    value: 'The option "--'.concat(opt.name).concat(opt.short !== void 0 ? "/-" + opt.short : "", '" is not yet implemented.')
  };
};
var notImplementedInCompose = function(opt) {
  return {
    type: MessageType.notTranslatable,
    value: 'The option "--'.concat(opt.name).concat(opt.short !== void 0 ? "/-" + opt.short : "", '" could not be translated to docker-compose.yml.')
  };
};
var processBoolean = function(opt) {
  var valueToSet = {};
  (0, import_set_value.default)(valueToSet, opt.path, true);
  return { path: opt.path, value: valueToSet, multiValue: opt.multiValue, additionalObject: void 0 };
};
var processOptionWithArgs = function(opt, value) {
  var val = getValue(value, opt);
  var valueToSet = {};
  (0, import_set_value.default)(valueToSet, opt.path, val);
  return { path: opt.path, value: valueToSet, multiValue: opt.multiValue, additionalObject: void 0 };
};
var processLoggingOption = function(opt, value) {
  var _a;
  var val = value.split("=");
  return processOptionWithArgs(opt, (_a = {}, _a[val[0]] = val[1], _a));
};
var processStorageOption = function(opt, value) {
  var _a;
  var val = value.split("=");
  return processOptionWithArgs(opt, (_a = {}, _a[val[0]] = val[1], _a));
};
var processNetworkOption = function(opt, value) {
  var _a, _b;
  var result = processOptionWithArgs(opt, (_a = {}, _a[value] = {}, _a));
  result.additionalObject = {
    networks: (_b = {}, _b[value] = {}, _b)
  };
  return result;
};
var processUlimitOption = function(opt, value) {
  var _a, _b;
  var parts = value.match(/(?<type>[^=]+)=(?<hardLimit>[^:]+)(:(?<softLimit>\S+))?/);
  if (parts !== null) {
    if (parts.length === 5) {
      if (parts.groups.softLimit === void 0) {
        return processOptionWithArgs(opt, (_a = {}, _a[parts.groups.type] = parseInt(parts.groups.hardLimit), _a));
      }
      return processOptionWithArgs(opt, (_b = {}, _b[parts.groups.type] = {
        hard: parseInt(parts.groups.hardLimit),
        soft: parseInt(parts.groups.softLimit)
      }, _b));
    }
  }
  return {
    type: MessageType.errorDuringConversion,
    value: 'The option "--'.concat(opt.name).concat(opt.short !== void 0 ? "/-" + opt.short : "", '" could not be translated to docker-compose.yml. The not translatable value was "').concat(value, '"')
  };
};

// node_modules/.pnpm/composerize-ts@0.6.2/node_modules/composerize-ts/dist/esm/options.js
var OPTIONS = [
  { name: "add-host", path: "extra_hosts", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "attach", short: "a", path: "", type: OptionType.withArgs, multiValue: false, action: notImplementedInCompose },
  { name: "blkio-weight", path: "blkio_config.weight", type: OptionType.withArgs, multiValue: false, composeType: "int", action: processOptionWithArgs },
  { name: "blkio-weight-device", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "cap-add", path: "cap_add", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "cap-drop", path: "cap_drop", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "cgroupns", path: "cgroup", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "cgroup-parent", path: "cgroup_parent", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "cidfile", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "cpu-count", path: "cpu_count", type: OptionType.withArgs, multiValue: false, composeType: "int", action: processOptionWithArgs },
  { name: "cpu-percent", path: "cpu_percent", type: OptionType.withArgs, multiValue: false, composeType: "float", action: processOptionWithArgs },
  { name: "cpu-period", path: "cpu_period", type: OptionType.withArgs, multiValue: false, composeType: "int", action: processOptionWithArgs },
  { name: "cpu-quota", path: "cpu_quota", type: OptionType.withArgs, multiValue: false, composeType: "int", action: processOptionWithArgs },
  { name: "cpu-rt-period", path: "cpu_rt_period", type: OptionType.withArgs, multiValue: false, composeType: "int", action: processOptionWithArgs },
  { name: "cpu-rt-runtime", path: "cpu_rt_runtime", type: OptionType.withArgs, multiValue: false, composeType: "int", action: processOptionWithArgs },
  { name: "cpu-shares", short: "c", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "cpus", path: "cpus", type: OptionType.withArgs, multiValue: false, composeType: "float", action: processOptionWithArgs },
  { name: "cpuset-cpus", path: "cpuset", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "cpuset-mems", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "detach", short: "d", path: "", type: OptionType.flag, multiValue: false, action: notImplementedInCompose },
  { name: "detach-keys", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "device", path: "devices", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "device-cgroup-rule", path: "device_cgroup_rules", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "device-read-bps", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "device-read-iops", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "device-write-bps", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "device-write-iops", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "disable-content-trust", path: "", type: OptionType.flag, multiValue: false, action: notYetImplemented },
  { name: "dns", path: "dns", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "dns-option", path: "dns_opt", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "dns-search", path: "dns_search", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "domainname", path: "domainname", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "entrypoint", path: "entrypoint", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "env", short: "e", path: "environment", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "env-file", path: "env_file", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "expose", path: "expose", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "gpus", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "group-add", path: "group_add", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "health-cmd", path: "healthcheck.test", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "health-interval", path: "healthcheck.interval", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "health-retries", path: "healthcheck.retries", type: OptionType.withArgs, multiValue: false, composeType: "int", action: processOptionWithArgs },
  { name: "health-start-period", path: "healthcheck.start_period", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "health-timeout", path: "healthcheck.timeout", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "hostname", short: "h", path: "hostname", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "init", path: "init", type: OptionType.flag, multiValue: false, action: processBoolean },
  { name: "interactive", short: "i", path: "stdin_open", type: OptionType.flag, multiValue: false, action: processBoolean },
  { name: "io-maxbandwidth", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "io-maxiops", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "ip", path: "networks.default.ipv4_address", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "ip6", path: "networks.default.ipv6_address", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "ipc", path: "ipc", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "isolation", path: "isolation", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "kernel-memory", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "label-file", path: "", type: OptionType.withArgs, multiValue: false, action: notImplementedInCompose },
  { name: "label", short: "l", path: "labels", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "link", path: "links", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "link-local-ip", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "log-driver", path: "logging.driver", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "log-opt", path: "logging.options", type: OptionType.withArgs, multiValue: false, action: processLoggingOption },
  { name: "mac-address", path: "mac_address", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "memory", short: "m", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "memory-swap", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "memory-swappiness", path: "mem_swappiness", type: OptionType.withArgs, multiValue: false, composeType: "int", action: processOptionWithArgs },
  { name: "memory-reservation", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "mount", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "name", path: "container_name", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "network", path: "networks", type: OptionType.withArgs, multiValue: true, action: processNetworkOption },
  { name: "network-alias", path: "networks.default.aliases", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "no-healthcheck", path: "", type: OptionType.flag, multiValue: false, action: notYetImplemented },
  { name: "oom-kill-disable", path: "oom_kill_disable", type: OptionType.flag, multiValue: false, action: processBoolean },
  { name: "oom-score-adj", path: "oom_score_adj", type: OptionType.withArgs, multiValue: false, composeType: "int", action: processOptionWithArgs },
  { name: "pid", path: "pid", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "pids-limit", path: "pids_limit", type: OptionType.withArgs, multiValue: false, composeType: "int", action: processOptionWithArgs },
  { name: "platform", path: "platform", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "privileged", path: "privileged", type: OptionType.flag, multiValue: false, action: processBoolean },
  { name: "publish", short: "p", path: "ports", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "publish-all", short: "P", path: "", type: OptionType.flag, multiValue: false, action: notImplementedInCompose },
  { name: "pull", path: "pull_policy", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "quiet", short: "q", path: "", type: OptionType.flag, multiValue: false, action: notImplementedInCompose },
  { name: "read-only", path: "read_only", type: OptionType.flag, multiValue: false, action: processBoolean },
  { name: "restart", path: "restart", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "rm", path: "", type: OptionType.flag, multiValue: false, action: notImplementedInCompose },
  { name: "runtime", path: "runtime", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "security-opt", path: "security_opt", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "shm-size", path: "shm_size", type: OptionType.withArgs, multiValue: false, composeType: "int", action: processOptionWithArgs },
  { name: "stop-signal", path: "stop_signal", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "stop-timeout", path: "stop_grace_period", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "storage-opt", path: "storage_opt", type: OptionType.withArgs, multiValue: false, action: processStorageOption },
  { name: "tmpfs", path: "tmpfs", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "tty", short: "t", path: "tty", type: OptionType.flag, multiValue: false, action: processBoolean },
  { name: "sysctl", path: "sysctls", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "ulimit", path: "ulimits", type: OptionType.withArgs, multiValue: false, composeType: "int", action: processUlimitOption },
  { name: "user", short: "u", path: "user", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "userns", path: "userns_mode", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "uts", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "volume-driver", path: "", type: OptionType.withArgs, multiValue: false, action: notYetImplemented },
  { name: "volumes-from", path: "volumes_from", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "volume", short: "v", path: "volumes", type: OptionType.withArgs, multiValue: true, action: processOptionWithArgs },
  { name: "workdir", short: "w", path: "working_dir", type: OptionType.withArgs, multiValue: false, action: processOptionWithArgs },
  { name: "help", path: "", type: OptionType.flag, multiValue: false, action: notImplementedInCompose }
];
var AllOptions = {};
OPTIONS.forEach(function(opt) {
  return AllOptions[opt.name] = opt;
});
var getOption = function(optionName) {
  return AllOptions[optionName] || OPTIONS.find(function(o) {
    return o.short === optionName;
  });
};
var getSupportedOptions = function() {
  var implemented = OPTIONS.filter(function(opt) {
    return opt.action !== notYetImplemented && opt.action !== notImplementedInCompose;
  }).map(function(opt) {
    return new SupportedOption(opt.name, opt.path, opt.short);
  });
  return implemented;
};

// node_modules/.pnpm/composerize-ts@0.6.2/node_modules/composerize-ts/dist/esm/util.js
var isResult = function(obj) {
  return obj.hasOwnProperty("path");
};

// node_modules/.pnpm/composerize-ts@0.6.2/node_modules/composerize-ts/dist/esm/cidr.js
var import_ip_cidr = __toESM(require_ip_cidr());
var abbreviate = function(a) {
  a = a.replace(/0000/g, "g");
  a = a.replace(/\:000/g, ":");
  a = a.replace(/\:00/g, ":");
  a = a.replace(/\:0/g, ":");
  a = a.replace(/g/g, "0");
  a = a.replace(/^0*/, "");
  var sections = a.split(/\:/g);
  var zPreviousFlag = false;
  var zeroStartIndex = -1;
  var zeroLength = 0;
  var zStartIndex = -1;
  var zLength = 0;
  for (var i = 0; i < 8; ++i) {
    var section = sections[i];
    var zFlag = section === "0";
    if (zFlag && !zPreviousFlag) {
      zStartIndex = i;
    }
    if (!zFlag && zPreviousFlag) {
      zLength = i - zStartIndex;
    }
    if (zLength > 1 && zLength > zeroLength) {
      zeroStartIndex = zStartIndex;
      zeroLength = zLength;
    }
    zPreviousFlag = section === "0";
  }
  if (zPreviousFlag) {
    zLength = 8 - zStartIndex;
  }
  if (zLength > 1 && zLength > zeroLength) {
    zeroStartIndex = zStartIndex;
    zeroLength = zLength;
  }
  if (zeroStartIndex >= 0 && zeroLength > 1) {
    sections.splice(zeroStartIndex, zeroLength, "g");
  }
  a = sections.join(":");
  a = a.replace(/\:g\:/g, "::");
  a = a.replace(/\:g/g, "::");
  a = a.replace(/g\:/g, "::");
  a = a.replace(/g/g, "::");
  return a;
};
var normalize = function(address) {
  if (import_ip_cidr.default.isValidCIDR(address)) {
    var cidr = new import_ip_cidr.default(address);
    var start = cidr.start();
    if (!cidr.addressStart.v4) {
      start = abbreviate(start);
    }
    return start + cidr.addressStart.subnet;
  }
  return "";
};

// node_modules/.pnpm/composerize-ts@0.6.2/node_modules/composerize-ts/dist/esm/parser.js
var import_set_value2 = __toESM(require_set_value());
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var _this = void 0;
var SHORT_OPT_STATE = "short-opt";
var LONG_OPT_STATE = "long-opt";
var WAITING_FOR_ARGUMENT_STATE = "waiting-for-arg";
var IMAGE_FOUND_STATE = "image-found";
var QUOTED_STRING = "quoted";
var ParserDto = (
  /** @class */
  function(_super) {
    __extends(ParserDto2, _super);
    function ParserDto2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.lexer = new import_flex_js.default();
      _this2.lastOpt = void 0;
      return _this2;
    }
    ParserDto2.prototype.asParseResult = function() {
      var parseResult = new ParseResult();
      parseResult.serviceName = this.serviceName;
      parseResult.properties = this.properties;
      parseResult.messages = this.messages;
      parseResult.additionalComposeObjects = this.additionalComposeObjects;
      return parseResult;
    };
    return ParserDto2;
  }(ParseResult)
);
var Pattern = {
  DOCKER_CMD: /docker (run|create)/,
  STRING: /[^="][^"'\s\t\r\n]+/,
  LONG_OPT_VALUE: /[a-z][a-z0-9\-]+/,
  IMAGE_NAME: new RegExp("(?:(?=[^:\\/]{1,253})(?!-)[a-zA-Z0-9-]{1,63}(?<!-)(?:\\.(?!-)[a-zA-Z0-9-]{1,63}(?<!-))*(?::[0-9]{1,5})?\\/)?((?![._-])(?:[a-z0-9._-]*)(?<![._-])(?:\\/(?![._-])[a-z0-9._-]*(?<![._-]))*)(?::(?![.-])[a-zA-Z0-9_.-]{1,128})?"),
  QUOTE_CHAR: /"/,
  LONG_OPT: /--/,
  SHORT_OPT: /-/,
  CHAR: /./,
  WS: /\s+/,
  WS_OR_EQUALS: /{WS}|=/
};
var prepareInput = function(input) {
  return input.replace(/'/g, '"');
};
var processOption = function(parserDto) {
  var opt = getOption(parserDto.lexer.text);
  parserDto.lastOpt = opt;
  if (opt === void 0) {
    parserDto.messages.push({
      type: MessageType.errorDuringConversion,
      value: "Unknown option: ".concat(parserDto.lexer.text)
    });
  } else {
    if (opt.type === OptionType.withArgs) {
      parserDto.lexer.pushState(WAITING_FOR_ARGUMENT_STATE);
    } else {
      var result = opt.action.call(_this, opt, parserDto.lexer);
      if (result !== void 0) {
        if (isResult(result)) {
          parserDto.properties.push(result);
          if (result.additionalObject !== void 0) {
            parserDto.additionalComposeObjects.push(result.additionalObject);
          }
        } else {
          parserDto.messages.push(result);
        }
      }
    }
  }
};
var processArgument = function(value, parserDto) {
  if (parserDto.lastOpt === void 0) {
    parserDto.messages.push({
      type: MessageType.errorDuringConversion,
      value: "Error while parsing. Got option value '".concat(value, "' 'but no option the value belongs to.")
    });
    return;
  }
  var result = parserDto.lastOpt.action.call(_this, parserDto.lastOpt, value, parserDto.lexer);
  if (result !== void 0) {
    if (isResult(result)) {
      parserDto.properties.push(result);
      if (result.additionalObject !== void 0) {
        parserDto.additionalComposeObjects.push(result.additionalObject);
      }
    } else {
      parserDto.messages.push(result);
    }
  }
};
var prepareLexer = function(debug) {
  var e_1, _a;
  var parserDto = new ParserDto();
  var lexer = parserDto.lexer;
  var properties = parserDto.properties;
  lexer.setIgnoreCase(false);
  lexer.setDebugEnabled(debug);
  lexer.addState(QUOTED_STRING, true);
  lexer.addState(SHORT_OPT_STATE, true);
  lexer.addState(LONG_OPT_STATE, true);
  lexer.addState(WAITING_FOR_ARGUMENT_STATE, true);
  lexer.addState(IMAGE_FOUND_STATE, true);
  try {
    for (var _b = __values(Object.entries(Pattern)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var _d = __read(_c.value, 2), name = _d[0], regexp = _d[1];
      lexer.addDefinition(name, regexp);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  lexer.addRule(Pattern.DOCKER_CMD);
  lexer.addRule(Pattern.WS);
  lexer.addRule(Pattern.SHORT_OPT, function(lexer2) {
    return lexer2.begin(SHORT_OPT_STATE);
  });
  lexer.addRule(Pattern.LONG_OPT, function(lexer2) {
    return lexer2.begin(LONG_OPT_STATE);
  });
  var str = "";
  lexer.addStateRule(WAITING_FOR_ARGUMENT_STATE, Pattern.QUOTE_CHAR, function(lexer2) {
    return lexer2.pushState(QUOTED_STRING);
  });
  lexer.addStateRule(QUOTED_STRING, Pattern.QUOTE_CHAR, function(lexer2) {
    lexer2.popState();
    var token = str;
    str = "";
    if (lexer2.state == WAITING_FOR_ARGUMENT_STATE) {
      processArgument(token, parserDto);
      lexer2.begin(import_flex_js.default.STATE_INITIAL);
    }
  });
  lexer.addStateRule(QUOTED_STRING, /[^\n\"]+/, function(lexer2) {
    str += lexer2.text;
  });
  lexer.addStateRule(SHORT_OPT_STATE, Pattern.WS, function(lexer2) {
    return lexer2.begin(import_flex_js.default.STATE_INITIAL);
  });
  lexer.addStateRule(SHORT_OPT_STATE, Pattern.CHAR, function() {
    return processOption(parserDto);
  });
  lexer.addStateRule(LONG_OPT_STATE, Pattern.LONG_OPT_VALUE, function() {
    return processOption(parserDto);
  });
  lexer.addStateRule(LONG_OPT_STATE, Pattern.WS, function(lexer2) {
    return lexer2.begin(import_flex_js.default.STATE_INITIAL);
  });
  lexer.addStateRule(WAITING_FOR_ARGUMENT_STATE, Pattern.WS_OR_EQUALS);
  lexer.addStateRule(WAITING_FOR_ARGUMENT_STATE, Pattern.STRING, function(lexer2) {
    processArgument(lexer2.text.trim(), parserDto);
    lexer2.begin(import_flex_js.default.STATE_INITIAL);
  });
  lexer.addStateRule(WAITING_FOR_ARGUMENT_STATE, Pattern.CHAR, function() {
    parserDto.messages.push({
      type: MessageType.errorDuringConversion,
      // @ts-ignore
      value: 'The option "--'.concat(parserDto.lastOpt.name).concat(
        // @ts-ignore
        parserDto.lastOpt.short !== void 0 ? "/-" + parserDto.lastOpt.short : "",
        '"'
      )
    });
  });
  lexer.addStateRule(import_flex_js.default.STATE_INITIAL, Pattern.IMAGE_NAME, function(lexer2) {
    lexer2.begin(IMAGE_FOUND_STATE);
    var imageName = lexer2.text;
    parserDto.serviceName = getServiceName(imageName);
    var valueToSet = {};
    (0, import_set_value2.default)(valueToSet, "image", imageName);
    properties.push({
      path: "image",
      value: valueToSet,
      multiValue: false,
      additionalObject: void 0
    });
  });
  lexer.addStateRule(IMAGE_FOUND_STATE, / .*/, function(lexer2) {
    var valueToSet = {};
    (0, import_set_value2.default)(valueToSet, "command", lexer2.text.trim());
    properties.push({
      path: "command",
      value: valueToSet,
      multiValue: false,
      additionalObject: void 0
    });
    lexer2.terminate();
  });
  return parserDto;
};
var tokenize = function(lexer, input) {
  lexer.setSource(input);
  lexer.lexAll();
};
var postProcessNetworkOption = function(dto) {
  var _a;
  var network = dto.properties.find(function(result) {
    return result.path === "networks";
  });
  var networkName = "default";
  if (network !== void 0) {
    networkName = Object.keys(network.value["networks"])[0];
    var networkRelatedProperties_1 = dto.properties.filter(function(result) {
      return result.path.startsWith("networks") && result.path !== "networks";
    });
    networkRelatedProperties_1.forEach(function(result) {
      var obj = result.value["networks"];
      Object.defineProperty(obj, networkName, Object.getOwnPropertyDescriptor(obj, "default"));
      delete obj["default"];
    });
  }
  var specificIpAddresses = [];
  var networkRelatedProperties = dto.properties.filter(function(result) {
    return result.path.startsWith("networks") && result.path !== "networks";
  });
  networkRelatedProperties.forEach(function(result) {
    if (result.path.includes("ipv4_address")) {
      specificIpAddresses.push(result.value.networks[networkName].ipv4_address + "/24");
    }
    if (result.path.includes("ipv6_address")) {
      specificIpAddresses.push(result.value.networks[networkName].ipv6_address + "/64");
    }
  });
  if (specificIpAddresses.length > 0) {
    var additionalNetworkConfig_1 = {
      networks: (_a = {}, _a[networkName] = {
        driver: "default",
        config: []
      }, _a)
    };
    specificIpAddresses.forEach(function(address) {
      additionalNetworkConfig_1.networks[networkName].config.push({ subnet: getCidr(address) });
    });
    dto.additionalComposeObjects.push(additionalNetworkConfig_1);
  }
};
var getCidr = function(ip) {
  return normalize("".concat(ip));
};
var getServiceName = function(image) {
  var name = image.includes("/") ? image.split("/")[1] : image;
  name = name.includes(":") ? name.split(":")[0] : name;
  return name;
};
var parse = function(command, debug) {
  var preparedInput = prepareInput(command);
  var parserDto = prepareLexer(debug);
  tokenize(parserDto.lexer, preparedInput);
  postProcessNetworkOption(parserDto);
  return parserDto.asParseResult();
};

// node_modules/.pnpm/composerize-ts@0.6.2/node_modules/composerize-ts/dist/esm/composerize.js
var YAML = __toESM(require_Yaml());

// node_modules/.pnpm/deepmerge-ts@5.1.0/node_modules/deepmerge-ts/dist/node/index.mjs
var actions = {
  defaultMerge: Symbol("deepmerge-ts: default merge"),
  skip: Symbol("deepmerge-ts: skip")
};
var actionsInto = {
  defaultMerge: actions.defaultMerge
};
function defaultMetaDataUpdater(previousMeta, metaMeta) {
  return metaMeta;
}
function getObjectType(object) {
  if (typeof object !== "object" || object === null) {
    return 0;
  }
  if (Array.isArray(object)) {
    return 2;
  }
  if (isRecord(object)) {
    return 1;
  }
  if (object instanceof Set) {
    return 3;
  }
  if (object instanceof Map) {
    return 4;
  }
  return 5;
}
function getKeys(objects) {
  const keys = /* @__PURE__ */ new Set();
  for (const object of objects) {
    for (const key of [
      ...Object.keys(object),
      ...Object.getOwnPropertySymbols(object)
    ]) {
      keys.add(key);
    }
  }
  return keys;
}
function objectHasProperty(object, property) {
  return typeof object === "object" && Object.prototype.propertyIsEnumerable.call(object, property);
}
function getIterableOfIterables(iterables) {
  return {
    // eslint-disable-next-line functional/functional-parameters
    *[Symbol.iterator]() {
      for (const iterable of iterables) {
        for (const value of iterable) {
          yield value;
        }
      }
    }
  };
}
var validRecordToStringValues = /* @__PURE__ */ new Set([
  "[object Object]",
  "[object Module]"
]);
function isRecord(value) {
  if (!validRecordToStringValues.has(Object.prototype.toString.call(value))) {
    return false;
  }
  const { constructor } = value;
  if (constructor === void 0) {
    return true;
  }
  const prototype = constructor.prototype;
  if (prototype === null || typeof prototype !== "object" || !validRecordToStringValues.has(Object.prototype.toString.call(prototype))) {
    return false;
  }
  if (!prototype.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function mergeRecords$2(values, utils, meta) {
  const result = {};
  for (const key of getKeys(values)) {
    const propValues = [];
    for (const value of values) {
      if (objectHasProperty(value, key)) {
        propValues.push(value[key]);
      }
    }
    if (propValues.length === 0) {
      continue;
    }
    const updatedMeta = utils.metaDataUpdater(meta, {
      key,
      parents: values
    });
    const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);
    if (propertyResult === actions.skip) {
      continue;
    }
    if (key === "__proto__") {
      Object.defineProperty(result, key, {
        value: propertyResult,
        configurable: true,
        enumerable: true,
        writable: true
      });
    } else {
      result[key] = propertyResult;
    }
  }
  return result;
}
function mergeArrays$2(values) {
  return values.flat();
}
function mergeSets$2(values) {
  return new Set(getIterableOfIterables(values));
}
function mergeMaps$2(values) {
  return new Map(getIterableOfIterables(values));
}
function mergeOthers$2(values) {
  return values.at(-1);
}
var defaultMergeFunctions = Object.freeze({
  __proto__: null,
  mergeArrays: mergeArrays$2,
  mergeMaps: mergeMaps$2,
  mergeOthers: mergeOthers$2,
  mergeRecords: mergeRecords$2,
  mergeSets: mergeSets$2
});
function deepmerge(...objects) {
  return deepmergeCustom({})(...objects);
}
function deepmergeCustom(options, rootMetaData) {
  const utils = getUtils(options, customizedDeepmerge);
  function customizedDeepmerge(...objects) {
    return mergeUnknowns(objects, utils, rootMetaData);
  }
  return customizedDeepmerge;
}
function getUtils(options, customizedDeepmerge) {
  return {
    defaultMergeFunctions,
    mergeFunctions: {
      ...defaultMergeFunctions,
      ...Object.fromEntries(Object.entries(options).filter(([key, option]) => Object.hasOwn(defaultMergeFunctions, key)).map(([key, option]) => option === false ? [key, mergeOthers$2] : [key, option]))
    },
    metaDataUpdater: options.metaDataUpdater ?? defaultMetaDataUpdater,
    deepmerge: customizedDeepmerge,
    useImplicitDefaultMerging: options.enableImplicitDefaultMerging ?? false,
    actions
  };
}
function mergeUnknowns(values, utils, meta) {
  if (values.length === 0) {
    return void 0;
  }
  if (values.length === 1) {
    return mergeOthers$1(values, utils, meta);
  }
  const type = getObjectType(values[0]);
  if (type !== 0 && type !== 5) {
    for (let m_index = 1; m_index < values.length; m_index++) {
      if (getObjectType(values[m_index]) === type) {
        continue;
      }
      return mergeOthers$1(values, utils, meta);
    }
  }
  switch (type) {
    case 1: {
      return mergeRecords$1(values, utils, meta);
    }
    case 2: {
      return mergeArrays$1(values, utils, meta);
    }
    case 3: {
      return mergeSets$1(values, utils, meta);
    }
    case 4: {
      return mergeMaps$1(values, utils, meta);
    }
    default: {
      return mergeOthers$1(values, utils, meta);
    }
  }
}
function mergeRecords$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeRecords(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeRecords !== utils.defaultMergeFunctions.mergeRecords) {
    return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);
  }
  return result;
}
function mergeArrays$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeArrays(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeArrays !== utils.defaultMergeFunctions.mergeArrays) {
    return utils.defaultMergeFunctions.mergeArrays(values);
  }
  return result;
}
function mergeSets$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeSets(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets) {
    return utils.defaultMergeFunctions.mergeSets(values);
  }
  return result;
}
function mergeMaps$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeMaps(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps) {
    return utils.defaultMergeFunctions.mergeMaps(values);
  }
  return result;
}
function mergeOthers$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeOthers(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeOthers !== utils.defaultMergeFunctions.mergeOthers) {
    return utils.defaultMergeFunctions.mergeOthers(values);
  }
  return result;
}
function mergeRecords(m_target, values, utils, meta) {
  for (const key of getKeys(values)) {
    const propValues = [];
    for (const value of values) {
      if (objectHasProperty(value, key)) {
        propValues.push(value[key]);
      }
    }
    if (propValues.length === 0) {
      continue;
    }
    const updatedMeta = utils.metaDataUpdater(meta, {
      key,
      parents: values
    });
    const propertyTarget = { value: propValues[0] };
    mergeUnknownsInto(propertyTarget, propValues, utils, updatedMeta);
    if (key === "__proto__") {
      Object.defineProperty(m_target, key, {
        value: propertyTarget.value,
        configurable: true,
        enumerable: true,
        writable: true
      });
    } else {
      m_target.value[key] = propertyTarget.value;
    }
  }
}
function mergeArrays(m_target, values) {
  m_target.value.push(...values.slice(1).flat());
}
function mergeSets(m_target, values) {
  for (const value of getIterableOfIterables(values.slice(1))) {
    m_target.value.add(value);
  }
}
function mergeMaps(m_target, values) {
  for (const [key, value] of getIterableOfIterables(values.slice(1))) {
    m_target.value.set(key, value);
  }
}
function mergeOthers(m_target, values) {
  m_target.value = values.at(-1);
}
var defaultMergeIntoFunctions = Object.freeze({
  __proto__: null,
  mergeArrays,
  mergeMaps,
  mergeOthers,
  mergeRecords,
  mergeSets
});
function mergeUnknownsInto(m_target, values, utils, meta) {
  if (values.length === 0) {
    return;
  }
  if (values.length === 1) {
    return void mergeOthersInto(m_target, values, utils, meta);
  }
  const type = getObjectType(m_target.value);
  if (type !== 0 && type !== 5) {
    for (let m_index = 1; m_index < values.length; m_index++) {
      if (getObjectType(values[m_index]) === type) {
        continue;
      }
      return void mergeOthersInto(m_target, values, utils, meta);
    }
  }
  switch (type) {
    case 1: {
      return void mergeRecordsInto(m_target, values, utils, meta);
    }
    case 2: {
      return void mergeArraysInto(m_target, values, utils, meta);
    }
    case 3: {
      return void mergeSetsInto(m_target, values, utils, meta);
    }
    case 4: {
      return void mergeMapsInto(m_target, values, utils, meta);
    }
    default: {
      return void mergeOthersInto(m_target, values, utils, meta);
    }
  }
}
function mergeRecordsInto(m_target, values, utils, meta) {
  const action = utils.mergeFunctions.mergeRecords(m_target, values, utils, meta);
  if (action === actionsInto.defaultMerge) {
    utils.defaultMergeFunctions.mergeRecords(m_target, values, utils, meta);
  }
}
function mergeArraysInto(m_target, values, utils, meta) {
  const action = utils.mergeFunctions.mergeArrays(m_target, values, utils, meta);
  if (action === actionsInto.defaultMerge) {
    utils.defaultMergeFunctions.mergeArrays(m_target, values);
  }
}
function mergeSetsInto(m_target, values, utils, meta) {
  const action = utils.mergeFunctions.mergeSets(m_target, values, utils, meta);
  if (action === actionsInto.defaultMerge) {
    utils.defaultMergeFunctions.mergeSets(m_target, values);
  }
}
function mergeMapsInto(m_target, values, utils, meta) {
  const action = utils.mergeFunctions.mergeMaps(m_target, values, utils, meta);
  if (action === actionsInto.defaultMerge) {
    utils.defaultMergeFunctions.mergeMaps(m_target, values);
  }
}
function mergeOthersInto(m_target, values, utils, meta) {
  const action = utils.mergeFunctions.mergeOthers(m_target, values, utils, meta);
  if (action === actionsInto.defaultMerge || m_target.value === actionsInto.defaultMerge) {
    utils.defaultMergeFunctions.mergeOthers(m_target, values);
  }
}

// node_modules/.pnpm/composerize-ts@0.6.2/node_modules/composerize-ts/dist/esm/composerize.js
var createComposeObjectStructure = function(parseResult, composeVersion) {
  var _a;
  var composeSpecification = {};
  composeSpecification = deepmerge(composeSpecification, {
    version: (Math.floor(composeVersion * 10) / 10).toString(),
    services: (_a = {}, _a[parseResult.serviceName] = {}, _a)
  });
  var service = {};
  parseResult.properties.forEach(function(result) {
    return service = deepmerge(result.value, service);
  });
  composeSpecification["services"][parseResult.serviceName] = service;
  if (parseResult.additionalComposeObjects !== void 0) {
    parseResult.additionalComposeObjects.forEach(function(obj) {
      return composeSpecification = deepmerge(composeSpecification, obj);
    });
  }
  return composeSpecification;
};
var composerize = function(command, composeVersion, debug) {
  if (composeVersion === void 0) {
    composeVersion = 3.9;
  }
  if (debug === void 0) {
    debug = false;
  }
  var parseResult = parse(command, debug);
  if (debug) {
    console.log("Parse result:");
    console.log(JSON.stringify(parseResult, null, 2));
  }
  var composeSpecification = createComposeObjectStructure(parseResult, composeVersion);
  return new ComposerizeResult(YAML.stringify(composeSpecification, 9, 4), parseResult.messages);
};
var listSupportedOptions = function() {
  return getSupportedOptions();
};
export {
  ComposerizeResult,
  MessageType,
  SupportedOption,
  composerize,
  listSupportedOptions
};
/*! Bundled license information:

is-primitive/index.js:
  (*!
   * is-primitive <https://github.com/jonschlinkert/is-primitive>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

isobject/index.js:
  (*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-plain-object/index.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

set-value/index.js:
  (*!
   * set-value <https://github.com/jonschlinkert/set-value>
   *
   * Copyright (c) Jon Schlinkert (https://github.com/jonschlinkert).
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=composerize-ts.js.map
