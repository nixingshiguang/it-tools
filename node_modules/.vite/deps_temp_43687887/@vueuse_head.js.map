{
  "version": 3,
  "sources": ["../../.pnpm/@vueuse+shared@12.0.0_typescript@5.2.2/node_modules/@vueuse/shared/index.mjs", "../../.pnpm/hookable@5.5.3/node_modules/hookable/dist/index.mjs", "../../.pnpm/unhead@0.5.1/node_modules/unhead/dist/index.mjs", "../../.pnpm/@unhead+vue@0.5.1_typescript@5.2.2_vue@3.3.4/node_modules/@unhead/vue/dist/index.mjs", "../../.pnpm/@unhead+ssr@0.5.1/node_modules/@unhead/ssr/dist/index.mjs", "../../.pnpm/@vueuse+head@1.0.0_typescript@5.2.2_vue@3.3.4/node_modules/@vueuse/head/dist/index.mjs"],
  "sourcesContent": ["import { shallowRef, watchEffect, readonly, ref, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, inject, provide, isRef, unref, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue';\n\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, {\n    ...options,\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  });\n  return readonly(result);\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  const update = () => {\n    dirty.value = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\" });\n  const get = typeof fn === \"function\" ? fn : fn.get;\n  const set = typeof fn === \"function\" ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = get(v);\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result))\n    result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createEventHook() {\n  const fns = /* @__PURE__ */ new Set();\n  const off = (fn) => {\n    fns.delete(fn);\n  };\n  const on = (fn) => {\n    fns.add(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (...args) => {\n    return Promise.all(Array.from(fns).map((fn) => fn(...args)));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return (...args) => {\n    if (!initialized) {\n      state = scope.run(() => stateFactory(...args));\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nconst localProvidedStateMap = /* @__PURE__ */ new WeakMap();\n\nconst injectLocal = (...args) => {\n  var _a;\n  const key = args[0];\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"injectLocal must be called in setup\");\n  if (localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))\n    return localProvidedStateMap.get(instance)[key];\n  return inject(...args);\n};\n\nconst provideLocal = (key, value) => {\n  var _a;\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"provideLocal must be called in setup\");\n  if (!localProvidedStateMap.has(instance))\n    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));\n  const localProvidedState = localProvidedStateMap.get(instance);\n  localProvidedState[key] = value;\n  provide(key, value);\n};\n\nfunction createInjectionState(composable, options) {\n  const key = (options == null ? void 0 : options.injectionKey) || Symbol(composable.name || \"InjectionState\");\n  const defaultValue = options == null ? void 0 : options.defaultValue;\n  const useProvidingState = (...args) => {\n    const state = composable(...args);\n    provideLocal(key, state);\n    return state;\n  };\n  const useInjectedState = () => injectLocal(key, defaultValue);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!scope) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = { ...obj };\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction toValue(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nconst resolveUnref = toValue;\n\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : toValue;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(\n    keys.map((key) => {\n      const value = obj[key];\n      return [\n        key,\n        typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n      ];\n    })\n  );\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nconst isClient = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nconst isWorker = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\nconst isDef = (val) => typeof val !== \"undefined\";\nconst notNullish = (val) => val != null;\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst isIOS = /* @__PURE__ */ getIsIOS();\nfunction getIsIOS() {\n  var _a, _b;\n  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\n    });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  let lastRejector = noop;\n  const _clearTimeout = (timer2) => {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  const filter = (invoke) => {\n    const duration = toValue(ms);\n    const maxDuration = toValue(options.maxWait);\n    if (timer)\n      _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise((resolve, reject) => {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(() => {\n          if (timer)\n            _clearTimeout(timer);\n          maxTimer = null;\n          resolve(invoke());\n        }, maxDuration);\n      }\n      timer = setTimeout(() => {\n        if (maxTimer)\n          _clearTimeout(maxTimer);\n        maxTimer = null;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(...args) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  let lastRejector = noop;\n  let lastValue;\n  let ms;\n  let trailing;\n  let leading;\n  let rejectOnCancel;\n  if (!isRef(args[0]) && typeof args[0] === \"object\")\n    ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);\n  else\n    [ms, trailing = true, leading = true, rejectOnCancel = false] = args;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  const filter = (_invoke) => {\n    const duration = toValue(ms);\n    const elapsed = Date.now() - lastExec;\n    const invoke = () => {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      lastValue = new Promise((resolve, reject) => {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(() => {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, Math.max(0, duration - elapsed));\n      });\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive: readonly(isActive), pause, resume, eventFilter };\n}\n\nfunction cacheStringFunction(fn) {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?\\d+\\.?\\d*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = Number.parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction objectOmit(obj, keys, omitUndefined = false) {\n  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n    return (!omitUndefined || value !== void 0) && !keys.includes(key);\n  }));\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\nfunction getLifeCycleTarget(target) {\n  return target || getCurrentInstance();\n}\n\nfunction toRef(...args) {\n  if (args.length !== 1)\n    return toRef$1(...args);\n  const r = args[0];\n  return typeof r === \"function\" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);\n}\nconst resolveRef = toRef;\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => predicate(toValue(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = toValue(defaultValue);\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = toValue(defaultValue);\n      trigger();\n    }, toValue(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(\n    debounceFilter(ms, options),\n    fn\n  );\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n  return createFilterWrapper(\n    throttleFilter(ms, trailing, leading, rejectOnCancel),\n    fn\n  );\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(\n    ref,\n    {\n      get,\n      set,\n      untrackedGet,\n      silentSet,\n      peek,\n      lay\n    },\n    { enumerable: true }\n  );\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    const [target, key, value] = args;\n    target[key] = value;\n  }\n}\n\nfunction watchWithFilter(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  return watch(\n    source,\n    createFilterWrapper(\n      eventFilter,\n      cb\n    ),\n    watchOptions\n  );\n}\n\nfunction watchPausable(source, cb, options = {}) {\n  const {\n    eventFilter: filter,\n    ...watchOptions\n  } = options;\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter\n    }\n  );\n  return { stop, pause, resume, isActive };\n}\n\nfunction syncRef(left, right, ...[options]) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options || {};\n  const watchers = [];\n  const transformLTR = \"ltr\" in transform && transform.ltr || ((v) => v);\n  const transformRTL = \"rtl\" in transform && transform.rtl || ((v) => v);\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchers.push(watchPausable(\n      left,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        right.value = transformLTR(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchers.push(watchPausable(\n      right,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        left.value = transformRTL(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  const stop = () => {\n    watchers.forEach((w) => w.stop());\n  };\n  return stop;\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return watch(\n    source,\n    (newValue) => targets.forEach((target) => target.value = newValue),\n    { flush, deep, immediate }\n  );\n}\n\nfunction toRefs(objectRef, options = {}) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        var _a;\n        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;\n        if (replaceRef) {\n          if (Array.isArray(objectRef.value)) {\n            const copy = [...objectRef.value];\n            copy[key] = v;\n            objectRef.value = copy;\n          } else {\n            const newObject = { ...objectRef.value, [key]: v };\n            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));\n            objectRef.value = newObject;\n          }\n        } else {\n          objectRef.value[key] = v;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeMount(fn, sync = true, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeMount(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeUnmount(fn, target);\n}\n\nfunction tryOnMounted(fn, sync = true, target) {\n  const instance = getLifeCycleTarget();\n  if (instance)\n    onMounted(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onUnmounted(fn, target);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        r,\n        (v) => {\n          if (condition(v) !== isNot) {\n            if (stop)\n              stop();\n            else\n              nextTick(() => stop == null ? void 0 : stop());\n            resolve(v);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => stop == null ? void 0 : stop())\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        [r, value],\n        ([v1, v2]) => {\n          if (isNot !== (v1 === v2)) {\n            if (stop)\n              stop();\n            else\n              nextTick(() => stop == null ? void 0 : stop());\n            resolve(v1);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => {\n          stop == null ? void 0 : stop();\n          return toValue(r);\n        })\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(toValue(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(toValue(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction defaultComparator(value, othVal) {\n  return value === othVal;\n}\nfunction useArrayDifference(...args) {\n  var _a;\n  const list = args[0];\n  const values = args[1];\n  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;\n  if (typeof compareFn === \"string\") {\n    const key = compareFn;\n    compareFn = (value, othVal) => value[key] === othVal[key];\n  }\n  return computed(() => toValue(list).filter((x) => toValue(values).findIndex((y) => compareFn(x, y)) === -1));\n}\n\nfunction useArrayEvery(list, fn) {\n  return computed(() => toValue(list).every((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction useArrayFilter(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).filter(fn));\n}\n\nfunction useArrayFind(list, fn) {\n  return computed(() => toValue(\n    toValue(list).find((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => toValue(list).findIndex((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction findLast(arr, cb) {\n  let index = arr.length;\n  while (index-- > 0) {\n    if (cb(arr[index], index, arr))\n      return arr[index];\n  }\n  return void 0;\n}\nfunction useArrayFindLast(list, fn) {\n  return computed(() => toValue(\n    !Array.prototype.findLast ? findLast(toValue(list), (element, index, array) => fn(toValue(element), index, array)) : toValue(list).findLast((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction isArrayIncludesOptions(obj) {\n  return isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\n}\nfunction useArrayIncludes(...args) {\n  var _a;\n  const list = args[0];\n  const value = args[1];\n  let comparator = args[2];\n  let formIndex = 0;\n  if (isArrayIncludesOptions(comparator)) {\n    formIndex = (_a = comparator.fromIndex) != null ? _a : 0;\n    comparator = comparator.comparator;\n  }\n  if (typeof comparator === \"string\") {\n    const key = comparator;\n    comparator = (element, value2) => element[key] === toValue(value2);\n  }\n  comparator = comparator != null ? comparator : (element, value2) => element === toValue(value2);\n  return computed(() => toValue(list).slice(formIndex).some((element, index, array) => comparator(\n    toValue(element),\n    toValue(value),\n    index,\n    toValue(array)\n  )));\n}\n\nfunction useArrayJoin(list, separator) {\n  return computed(() => toValue(list).map((i) => toValue(i)).join(toValue(separator)));\n}\n\nfunction useArrayMap(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).map(fn));\n}\n\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(toValue(sum), toValue(value), index);\n  return computed(() => {\n    const resolved = toValue(list);\n    return args.length ? resolved.reduce(reduceCallback, typeof args[0] === \"function\" ? toValue(args[0]()) : toValue(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\nfunction useArraySome(list, fn) {\n  return computed(() => toValue(list).some((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction uniqueElementsBy(array, fn) {\n  return array.reduce((acc, v) => {\n    if (!acc.some((x) => fn(v, x, array)))\n      acc.push(v);\n    return acc;\n  }, []);\n}\nfunction useArrayUnique(list, compareFn) {\n  return computed(() => {\n    const resolvedList = toValue(list).map((element) => toValue(element));\n    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\n  });\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  let _initialValue = unref(initialValue);\n  const count = ref(initialValue);\n  const {\n    max = Number.POSITIVE_INFINITY,\n    min = Number.NEGATIVE_INFINITY\n  } = options;\n  const inc = (delta = 1) => count.value = Math.max(Math.min(max, count.value + delta), min);\n  const dec = (delta = 1) => count.value = Math.min(Math.max(min, count.value - delta), max);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = _initialValue) => {\n    _initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[T\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/i;\nconst REGEX_FORMAT = /[YMDHhms]o|\\[([^\\]]+)\\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n}\nfunction formatOrdinal(num) {\n  const suffixes = [\"th\", \"st\", \"nd\", \"rd\"];\n  const v = num % 100;\n  return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);\n}\nfunction formatDate(date, formatStr, options = {}) {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const matches = {\n    Yo: () => formatOrdinal(years),\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    Mo: () => formatOrdinal(month + 1),\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(toValue(options.locales), { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(toValue(options.locales), { month: \"long\" }),\n    D: () => String(days),\n    Do: () => formatOrdinal(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    Ho: () => formatOrdinal(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    ho: () => formatOrdinal(hours % 12 || 12),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mo: () => formatOrdinal(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    so: () => formatOrdinal(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(toValue(options.locales), { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(toValue(options.locales), { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(toValue(options.locales), { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true)\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => {\n    var _a2, _b;\n    return (_b = $1 != null ? $1 : (_a2 = matches[match]) == null ? void 0 : _a2.call(matches)) != null ? _b : match;\n  });\n}\nfunction normalizeDate(date) {\n  if (date === null)\n    return new Date(Number.NaN);\n  if (date === void 0)\n    return /* @__PURE__ */ new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n}\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(toValue(date)), toValue(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    const intervalValue = toValue(interval);\n    if (intervalValue <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    if (isActive.value)\n      timer = setInterval(cb, intervalValue);\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || typeof interval === \"function\") {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = ref(0);\n  const update = () => counter.value += 1;\n  const reset = () => {\n    counter.value = 0;\n  };\n  const controls = useIntervalFn(\n    callback ? () => {\n      update();\n      callback(counter.value);\n    } : update,\n    interval,\n    { immediate }\n  );\n  if (exposeControls) {\n    return {\n      counter,\n      reset,\n      ...controls\n    };\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(\n    source,\n    () => ms.value = timestamp(),\n    options\n  );\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, toValue(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending: readonly(isPending),\n    start,\n    stop\n  };\n}\n\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(\n    callback != null ? callback : noop,\n    interval,\n    options\n  );\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return {\n      ready,\n      ...controls\n    };\n  } else {\n    return ready;\n  }\n}\n\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = toValue(value);\n    if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && Number.isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\nfunction useToString(value) {\n  return computed(() => `${toValue(value)}`);\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = toValue(truthyValue);\n      _value.value = _value.value === truthy ? toValue(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [...source instanceof Function ? source() : Array.isArray(source) ? source : toValue(source)];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = Array.from({ length: oldList.length });\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nfunction watchAtMost(source, cb, options) {\n  const {\n    count,\n    ...watchOptions\n  } = options;\n  const current = ref(0);\n  const stop = watchWithFilter(\n    source,\n    (...args) => {\n      current.value += 1;\n      if (current.value >= toValue(count))\n        nextTick(() => stop());\n      cb(...args);\n    },\n    watchOptions\n  );\n  return { count: current, stop };\n}\n\nfunction watchDebounced(source, cb, options = {}) {\n  const {\n    debounce = 0,\n    maxWait = void 0,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: debounceFilter(debounce, { maxWait })\n    }\n  );\n}\n\nfunction watchDeep(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      deep: true\n    }\n  );\n}\n\nfunction watchIgnorable(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  const filteredCb = createFilterWrapper(\n    eventFilter,\n    cb\n  );\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(\n      source,\n      (...args) => {\n        if (!ignore.value)\n          filteredCb(...args);\n      },\n      watchOptions\n    );\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(\n      watch(\n        source,\n        () => {\n          syncCounter.value++;\n        },\n        { ...watchOptions, flush: \"sync\" }\n      )\n    );\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(\n      watch(\n        source,\n        (...args) => {\n          const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n          ignoreCounter.value = 0;\n          syncCounter.value = 0;\n          if (ignore)\n            return;\n          filteredCb(...args);\n        },\n        watchOptions\n      )\n    );\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchImmediate(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      immediate: true\n    }\n  );\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n  return stop;\n}\n\nfunction watchThrottled(source, cb, options = {}) {\n  const {\n    throttle = 0,\n    trailing = true,\n    leading = true,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: throttleFilter(throttle, trailing, leading)\n    }\n  );\n}\n\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return {\n    ...res,\n    trigger\n  };\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => toValue(item));\n  return toValue(sources);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  const stop = watch(\n    source,\n    (v, ov, onInvalidate) => {\n      if (v) {\n        if (options == null ? void 0 : options.once)\n          nextTick(() => stop());\n        cb(v, ov, onInvalidate);\n      }\n    },\n    {\n      ...options,\n      once: false\n    }\n  );\n  return stop;\n}\n\nexport { assert, refAutoReset as autoResetRef, bypassFilter, camelize, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, computedEager as eagerComputed, extendRef, formatDate, get, getLifeCycleTarget, hasOwn, hyphenate, identity, watchIgnorable as ignorableWatch, increaseWithUnit, injectLocal, invoke, isClient, isDef, isDefined, isIOS, isObject, isWorker, makeDestructurable, noop, normalizeDate, notNullish, now, objectEntries, objectOmit, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, provideLocal, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRef, toRefs, toValue, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayDifference, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayIncludes, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchDeep, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n", "function flatHooks(configHooks, hooks = {}, parentName) {\n  for (const key in configHooks) {\n    const subHook = configHooks[key];\n    const name = parentName ? `${parentName}:${key}` : key;\n    if (typeof subHook === \"object\" && subHook !== null) {\n      flatHooks(subHook, hooks, name);\n    } else if (typeof subHook === \"function\") {\n      hooks[name] = subHook;\n    }\n  }\n  return hooks;\n}\nfunction mergeHooks(...hooks) {\n  const finalHooks = {};\n  for (const hook of hooks) {\n    const flatenHook = flatHooks(hook);\n    for (const key in flatenHook) {\n      if (finalHooks[key]) {\n        finalHooks[key].push(flatenHook[key]);\n      } else {\n        finalHooks[key] = [flatenHook[key]];\n      }\n    }\n  }\n  for (const key in finalHooks) {\n    if (finalHooks[key].length > 1) {\n      const array = finalHooks[key];\n      finalHooks[key] = (...arguments_) => serial(array, (function_) => function_(...arguments_));\n    } else {\n      finalHooks[key] = finalHooks[key][0];\n    }\n  }\n  return finalHooks;\n}\nfunction serial(tasks, function_) {\n  return tasks.reduce(\n    (promise, task) => promise.then(() => function_(task)),\n    Promise.resolve()\n  );\n}\nconst defaultTask = { run: (function_) => function_() };\nconst _createTask = () => defaultTask;\nconst createTask = typeof console.createTask !== \"undefined\" ? console.createTask : _createTask;\nfunction serialTaskCaller(hooks, args) {\n  const name = args.shift();\n  const task = createTask(name);\n  return hooks.reduce(\n    (promise, hookFunction) => promise.then(() => task.run(() => hookFunction(...args))),\n    Promise.resolve()\n  );\n}\nfunction parallelTaskCaller(hooks, args) {\n  const name = args.shift();\n  const task = createTask(name);\n  return Promise.all(hooks.map((hook) => task.run(() => hook(...args))));\n}\nfunction serialCaller(hooks, arguments_) {\n  return hooks.reduce(\n    (promise, hookFunction) => promise.then(() => hookFunction(...arguments_ || [])),\n    Promise.resolve()\n  );\n}\nfunction parallelCaller(hooks, args) {\n  return Promise.all(hooks.map((hook) => hook(...args || [])));\n}\nfunction callEachWith(callbacks, arg0) {\n  for (const callback of [...callbacks]) {\n    callback(arg0);\n  }\n}\n\nclass Hookable {\n  constructor() {\n    this._hooks = {};\n    this._before = void 0;\n    this._after = void 0;\n    this._deprecatedMessages = void 0;\n    this._deprecatedHooks = {};\n    this.hook = this.hook.bind(this);\n    this.callHook = this.callHook.bind(this);\n    this.callHookWith = this.callHookWith.bind(this);\n  }\n  hook(name, function_, options = {}) {\n    if (!name || typeof function_ !== \"function\") {\n      return () => {\n      };\n    }\n    const originalName = name;\n    let dep;\n    while (this._deprecatedHooks[name]) {\n      dep = this._deprecatedHooks[name];\n      name = dep.to;\n    }\n    if (dep && !options.allowDeprecated) {\n      let message = dep.message;\n      if (!message) {\n        message = `${originalName} hook has been deprecated` + (dep.to ? `, please use ${dep.to}` : \"\");\n      }\n      if (!this._deprecatedMessages) {\n        this._deprecatedMessages = /* @__PURE__ */ new Set();\n      }\n      if (!this._deprecatedMessages.has(message)) {\n        console.warn(message);\n        this._deprecatedMessages.add(message);\n      }\n    }\n    if (!function_.name) {\n      try {\n        Object.defineProperty(function_, \"name\", {\n          get: () => \"_\" + name.replace(/\\W+/g, \"_\") + \"_hook_cb\",\n          configurable: true\n        });\n      } catch {\n      }\n    }\n    this._hooks[name] = this._hooks[name] || [];\n    this._hooks[name].push(function_);\n    return () => {\n      if (function_) {\n        this.removeHook(name, function_);\n        function_ = void 0;\n      }\n    };\n  }\n  hookOnce(name, function_) {\n    let _unreg;\n    let _function = (...arguments_) => {\n      if (typeof _unreg === \"function\") {\n        _unreg();\n      }\n      _unreg = void 0;\n      _function = void 0;\n      return function_(...arguments_);\n    };\n    _unreg = this.hook(name, _function);\n    return _unreg;\n  }\n  removeHook(name, function_) {\n    if (this._hooks[name]) {\n      const index = this._hooks[name].indexOf(function_);\n      if (index !== -1) {\n        this._hooks[name].splice(index, 1);\n      }\n      if (this._hooks[name].length === 0) {\n        delete this._hooks[name];\n      }\n    }\n  }\n  deprecateHook(name, deprecated) {\n    this._deprecatedHooks[name] = typeof deprecated === \"string\" ? { to: deprecated } : deprecated;\n    const _hooks = this._hooks[name] || [];\n    delete this._hooks[name];\n    for (const hook of _hooks) {\n      this.hook(name, hook);\n    }\n  }\n  deprecateHooks(deprecatedHooks) {\n    Object.assign(this._deprecatedHooks, deprecatedHooks);\n    for (const name in deprecatedHooks) {\n      this.deprecateHook(name, deprecatedHooks[name]);\n    }\n  }\n  addHooks(configHooks) {\n    const hooks = flatHooks(configHooks);\n    const removeFns = Object.keys(hooks).map(\n      (key) => this.hook(key, hooks[key])\n    );\n    return () => {\n      for (const unreg of removeFns.splice(0, removeFns.length)) {\n        unreg();\n      }\n    };\n  }\n  removeHooks(configHooks) {\n    const hooks = flatHooks(configHooks);\n    for (const key in hooks) {\n      this.removeHook(key, hooks[key]);\n    }\n  }\n  removeAllHooks() {\n    for (const key in this._hooks) {\n      delete this._hooks[key];\n    }\n  }\n  callHook(name, ...arguments_) {\n    arguments_.unshift(name);\n    return this.callHookWith(serialTaskCaller, name, ...arguments_);\n  }\n  callHookParallel(name, ...arguments_) {\n    arguments_.unshift(name);\n    return this.callHookWith(parallelTaskCaller, name, ...arguments_);\n  }\n  callHookWith(caller, name, ...arguments_) {\n    const event = this._before || this._after ? { name, args: arguments_, context: {} } : void 0;\n    if (this._before) {\n      callEachWith(this._before, event);\n    }\n    const result = caller(\n      name in this._hooks ? [...this._hooks[name]] : [],\n      arguments_\n    );\n    if (result instanceof Promise) {\n      return result.finally(() => {\n        if (this._after && event) {\n          callEachWith(this._after, event);\n        }\n      });\n    }\n    if (this._after && event) {\n      callEachWith(this._after, event);\n    }\n    return result;\n  }\n  beforeEach(function_) {\n    this._before = this._before || [];\n    this._before.push(function_);\n    return () => {\n      if (this._before !== void 0) {\n        const index = this._before.indexOf(function_);\n        if (index !== -1) {\n          this._before.splice(index, 1);\n        }\n      }\n    };\n  }\n  afterEach(function_) {\n    this._after = this._after || [];\n    this._after.push(function_);\n    return () => {\n      if (this._after !== void 0) {\n        const index = this._after.indexOf(function_);\n        if (index !== -1) {\n          this._after.splice(index, 1);\n        }\n      }\n    };\n  }\n}\nfunction createHooks() {\n  return new Hookable();\n}\n\nconst isBrowser = typeof window !== \"undefined\";\nfunction createDebugger(hooks, _options = {}) {\n  const options = {\n    inspect: isBrowser,\n    group: isBrowser,\n    filter: () => true,\n    ..._options\n  };\n  const _filter = options.filter;\n  const filter = typeof _filter === \"string\" ? (name) => name.startsWith(_filter) : _filter;\n  const _tag = options.tag ? `[${options.tag}] ` : \"\";\n  const logPrefix = (event) => _tag + event.name + \"\".padEnd(event._id, \"\\0\");\n  const _idCtr = {};\n  const unsubscribeBefore = hooks.beforeEach((event) => {\n    if (filter !== void 0 && !filter(event.name)) {\n      return;\n    }\n    _idCtr[event.name] = _idCtr[event.name] || 0;\n    event._id = _idCtr[event.name]++;\n    console.time(logPrefix(event));\n  });\n  const unsubscribeAfter = hooks.afterEach((event) => {\n    if (filter !== void 0 && !filter(event.name)) {\n      return;\n    }\n    if (options.group) {\n      console.groupCollapsed(event.name);\n    }\n    if (options.inspect) {\n      console.timeLog(logPrefix(event), event.args);\n    } else {\n      console.timeEnd(logPrefix(event));\n    }\n    if (options.group) {\n      console.groupEnd();\n    }\n    _idCtr[event.name]--;\n  });\n  return {\n    /** Stop debugging and remove listeners */\n    close: () => {\n      unsubscribeBefore();\n      unsubscribeAfter();\n    }\n  };\n}\n\nexport { Hookable, createDebugger, createHooks, flatHooks, mergeHooks, parallelCaller, serial, serialCaller };\n", "import { createHooks } from 'hookable';\n\nconst HasElementTags = [\n  \"base\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\nconst ValidHeadTags = [\n  \"title\",\n  \"titleTemplate\",\n  \"base\",\n  \"htmlAttrs\",\n  \"bodyAttrs\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\nconst TagConfigKeys = [\"tagPosition\", \"tagPriority\", \"tagDuplicateStrategy\"];\n\nfunction normaliseTag(tagName, input) {\n  const tag = { tag: tagName, props: {} };\n  if (tagName === \"title\" || tagName === \"titleTemplate\") {\n    tag.children = input;\n    return tag;\n  }\n  tag.props = normaliseProps({ ...input });\n  [\"children\", \"innerHtml\", \"innerHTML\"].forEach((key) => {\n    if (typeof tag.props[key] !== \"undefined\") {\n      tag.children = tag.props[key];\n      delete tag.props[key];\n    }\n  });\n  Object.keys(tag.props).filter((k) => TagConfigKeys.includes(k)).forEach((k) => {\n    tag[k] = tag.props[k];\n    delete tag.props[k];\n  });\n  if (typeof tag.props.class === \"object\" && !Array.isArray(tag.props.class)) {\n    tag.props.class = Object.keys(tag.props.class).filter((k) => tag.props.class[k]);\n  }\n  if (Array.isArray(tag.props.class))\n    tag.props.class = tag.props.class.join(\" \");\n  if (tag.props.content && Array.isArray(tag.props.content)) {\n    return tag.props.content.map((v, i) => {\n      const newTag = { ...tag, props: { ...tag.props } };\n      newTag.props.content = v;\n      newTag.key = `${tag.props.name || tag.props.property}:${i}`;\n      return newTag;\n    });\n  }\n  return tag;\n}\nfunction normaliseProps(props) {\n  for (const k in props) {\n    if (String(props[k]) === \"true\") {\n      props[k] = \"\";\n    } else if (String(props[k]) === \"false\") {\n      delete props[k];\n    }\n  }\n  return props;\n}\n\nfunction unpackToArray(input, options) {\n  const unpacked = [];\n  const kFn = options.resolveKeyData || ((ctx) => ctx.key);\n  const vFn = options.resolveValueData || ((ctx) => ctx.value);\n  for (const [k, v] of Object.entries(input)) {\n    unpacked.push(...(Array.isArray(v) ? v : [v]).map((i) => {\n      const ctx = { key: k, value: i };\n      const val = vFn(ctx);\n      if (typeof val === \"object\")\n        return unpackToArray(val, options);\n      if (Array.isArray(val))\n        return val;\n      return {\n        [typeof options.key === \"function\" ? options.key(ctx) : options.key]: kFn(ctx),\n        [typeof options.value === \"function\" ? options.value(ctx) : options.value]: val\n      };\n    }).flat());\n  }\n  return unpacked;\n}\n\nfunction unpackToString(value, options) {\n  return Object.entries(value).map(([key, value2]) => {\n    if (typeof value2 === \"object\")\n      value2 = unpackToString(value2, options);\n    if (options.resolve) {\n      const resolved = options.resolve({ key, value: value2 });\n      if (resolved)\n        return resolved;\n    }\n    if (typeof value2 === \"number\")\n      value2 = value2.toString();\n    if (typeof value2 === \"string\" && options.wrapValue) {\n      value2 = value2.replace(new RegExp(options.wrapValue, \"g\"), `\\\\${options.wrapValue}`);\n      value2 = `${options.wrapValue}${value2}${options.wrapValue}`;\n    }\n    return `${key}${options.keyValueSeparator || \"\"}${value2}`;\n  }).join(options.entrySeparator || \"\");\n}\n\nconst MetaPackingSchema = {\n  robots: {\n    unpack: {\n      keyValueSeparator: \":\"\n    }\n  },\n  contentSecurityPolicy: {\n    unpack: {\n      keyValueSeparator: \" \",\n      entrySeparator: \"; \"\n    },\n    metaKey: \"http-equiv\"\n  },\n  fbAppId: {\n    keyValue: \"fb:app_id\",\n    metaKey: \"property\"\n  },\n  msapplicationTileImage: {\n    keyValue: \"msapplication-TileImage\"\n  },\n  msapplicationTileColor: {\n    keyValue: \"msapplication-TileColor\"\n  },\n  msapplicationConfig: {\n    keyValue: \"msapplication-Config\"\n  },\n  charset: {\n    metaKey: \"charset\"\n  },\n  contentType: {\n    metaKey: \"http-equiv\"\n  },\n  defaultStyle: {\n    metaKey: \"http-equiv\"\n  },\n  xUaCompatible: {\n    metaKey: \"http-equiv\"\n  },\n  refresh: {\n    metaKey: \"http-equiv\"\n  }\n};\nfunction resolveMetaKeyType(key) {\n  return PropertyPrefixKeys.test(key) ? \"property\" : MetaPackingSchema[key]?.metaKey || \"name\";\n}\n\nfunction unpackMeta(input) {\n  return unpackToArray(input, {\n    key({ key }) {\n      return resolveMetaKeyType(key);\n    },\n    value({ key }) {\n      return key === \"charset\" ? \"charset\" : \"content\";\n    },\n    resolveKeyData({ key }) {\n      return MetaPackingSchema[key]?.keyValue || fixKeyCase(key);\n    },\n    resolveValueData({ value, key }) {\n      if (typeof value === \"object\") {\n        const definition = MetaPackingSchema[key];\n        if (key === \"refresh\")\n          return `${value.seconds};url=${value.url}`;\n        return unpackToString(\n          changeKeyCasingDeep(value),\n          {\n            entrySeparator: \", \",\n            keyValueSeparator: \"=\",\n            resolve({ value: value2, key: key2 }) {\n              if (typeof value2 === \"boolean\")\n                return `${key2}`;\n            },\n            ...definition?.unpack\n          }\n        );\n      }\n      return typeof value === \"number\" ? value.toString() : value;\n    }\n  });\n}\n\nconst PropertyPrefixKeys = /^(og|twitter|fb)/;\nfunction fixKeyCase(key) {\n  key = key.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  if (PropertyPrefixKeys.test(key)) {\n    key = key.replace(\"secure-url\", \"secure_url\").replace(/-/g, \":\");\n  }\n  return key;\n}\nfunction changeKeyCasingDeep(input) {\n  if (Array.isArray(input)) {\n    return input.map((entry) => changeKeyCasingDeep(entry));\n  }\n  if (typeof input !== \"object\" || Array.isArray(input))\n    return input;\n  const output = {};\n  for (const [key, value] of Object.entries(input))\n    output[fixKeyCase(key)] = changeKeyCasingDeep(value);\n  return output;\n}\n\nconst tagWeight = (tag) => {\n  if (typeof tag.tagPriority === \"number\")\n    return tag.tagPriority;\n  switch (tag.tag) {\n    case \"base\":\n      return -1;\n    case \"title\":\n      return 1;\n    case \"meta\":\n      if (tag.props.charset)\n        return -2;\n      if (tag.props[\"http-equiv\"] === \"content-security-policy\")\n        return 0;\n      return 10;\n    default:\n      return 10;\n  }\n};\nconst sortTags = (aTag, bTag) => {\n  return tagWeight(aTag) - tagWeight(bTag);\n};\n\nconst UniqueTags = [\"base\", \"title\", \"titleTemplate\", \"bodyAttrs\", \"htmlAttrs\"];\nconst ArrayMetaProperties = [\n  \"og:image\",\n  \"og:video\",\n  \"og:audio\",\n  \"og:locale:alternate\",\n  \"video:actor\",\n  \"video:director\",\n  \"video:writer\",\n  \"video:tag\",\n  \"article:author\",\n  \"article:tag\",\n  \"book:tag\",\n  \"book:author\",\n  \"music:album\",\n  \"music:musician\"\n];\nfunction tagDedupeKey(tag) {\n  const { props, tag: tagName } = tag;\n  if (UniqueTags.includes(tagName))\n    return tagName;\n  if (tagName === \"link\" && props.rel === \"canonical\")\n    return \"canonical\";\n  if (props.charset)\n    return \"charset\";\n  const name = [\"id\"];\n  if (tagName === \"meta\")\n    name.push(...[\"name\", \"property\", \"http-equiv\"]);\n  for (const n of name) {\n    if (typeof props[n] !== \"undefined\") {\n      const val = String(props[n]);\n      if (ArrayMetaProperties.findIndex((p) => val.startsWith(p)) !== -1)\n        return false;\n      return `${tagName}:${n}:${val}`;\n    }\n  }\n  return false;\n}\n\nconst renderTitleTemplate = (template, title) => {\n  if (template == null)\n    return title || null;\n  if (typeof template === \"function\")\n    return template(title);\n  return template.replace(\"%s\", title ?? \"\");\n};\nfunction resolveTitleTemplateFromTags(tags) {\n  const titleTemplateIdx = tags.findIndex((i) => i.tag === \"titleTemplate\");\n  const titleIdx = tags.findIndex((i) => i.tag === \"title\");\n  if (titleIdx !== -1 && titleTemplateIdx !== -1) {\n    const newTitle = renderTitleTemplate(\n      tags[titleTemplateIdx].children,\n      tags[titleIdx].children\n    );\n    if (newTitle !== null) {\n      tags[titleIdx].children = newTitle || tags[titleIdx].children;\n    } else {\n      delete tags[titleIdx];\n    }\n  } else if (titleTemplateIdx !== -1) {\n    const newTitle = renderTitleTemplate(\n      tags[titleTemplateIdx].children\n    );\n    if (newTitle !== null) {\n      tags[titleTemplateIdx].children = newTitle;\n      tags[titleTemplateIdx].tag = \"title\";\n    }\n  }\n  if (titleTemplateIdx !== -1) {\n    delete tags[titleTemplateIdx];\n  }\n  return tags.filter(Boolean);\n}\n\nconst DedupesTagsPlugin = (options) => {\n  options = options || {};\n  const dedupeKeys = options.dedupeKeys || [\"hid\", \"vmid\", \"key\"];\n  return defineHeadPlugin({\n    hooks: {\n      \"tag:normalise\": function({ tag }) {\n        dedupeKeys.forEach((key) => {\n          if (tag.props[key]) {\n            tag.key = tag.props[key];\n            delete tag.props[key];\n          }\n        });\n        const dedupe = tag.key ? `${tag.tag}:${tag.key}` : tagDedupeKey(tag);\n        if (dedupe)\n          tag._d = dedupe;\n      },\n      \"tags:resolve\": function(ctx) {\n        const deduping = {};\n        ctx.tags.forEach((tag) => {\n          let dedupeKey = tag._d || tag._p;\n          const dupedTag = deduping[dedupeKey];\n          if (dupedTag) {\n            let strategy = tag?.tagDuplicateStrategy;\n            if (!strategy && (tag.tag === \"htmlAttrs\" || tag.tag === \"bodyAttrs\"))\n              strategy = \"merge\";\n            if (strategy === \"merge\") {\n              const oldProps = dupedTag.props;\n              [\"class\", \"style\"].forEach((key) => {\n                if (tag.props[key] && oldProps[key]) {\n                  if (key === \"style\" && !oldProps[key].endsWith(\";\"))\n                    oldProps[key] += \";\";\n                  tag.props[key] = `${oldProps[key]} ${tag.props[key]}`;\n                }\n              });\n              deduping[dedupeKey].props = {\n                ...oldProps,\n                ...tag.props\n              };\n              return;\n            } else if (tag._e === dupedTag._e) {\n              dedupeKey = tag._d = `${dedupeKey}:${tag._p}`;\n            }\n            const propCount = Object.keys(tag.props).length;\n            if ((propCount === 0 || propCount === 1 && typeof tag.props[\"data-h-key\"] !== \"undefined\") && !tag.children) {\n              delete deduping[dedupeKey];\n              return;\n            }\n          }\n          deduping[dedupeKey] = tag;\n        });\n        ctx.tags = Object.values(deduping);\n      }\n    }\n  });\n};\n\nconst SortTagsPlugin = () => {\n  return defineHeadPlugin({\n    hooks: {\n      \"tags:resolve\": (ctx) => {\n        const tagIndexForKey = (key) => ctx.tags.find((tag) => tag._d === key)?._p;\n        for (const tag of ctx.tags) {\n          if (!tag.tagPriority || typeof tag.tagPriority === \"number\")\n            continue;\n          const modifiers = [{ prefix: \"before:\", offset: -1 }, { prefix: \"after:\", offset: 1 }];\n          for (const { prefix, offset } of modifiers) {\n            if (tag.tagPriority.startsWith(prefix)) {\n              const key = tag.tagPriority.replace(prefix, \"\");\n              const index = tagIndexForKey(key);\n              if (typeof index !== \"undefined\")\n                tag._p = index + offset;\n            }\n          }\n        }\n        ctx.tags.sort((a, b) => a._p - b._p).sort(sortTags);\n      }\n    }\n  });\n};\n\nconst TitleTemplatePlugin = () => {\n  return defineHeadPlugin({\n    hooks: {\n      \"tags:resolve\": (ctx) => {\n        ctx.tags = resolveTitleTemplateFromTags(ctx.tags);\n      }\n    }\n  });\n};\n\nconst DeprecatedTagAttrPlugin = () => {\n  return defineHeadPlugin({\n    hooks: {\n      \"tag:normalise\": function({ tag }) {\n        if (typeof tag.props.body !== \"undefined\") {\n          tag.tagPosition = \"bodyClose\";\n          delete tag.props.body;\n        }\n      }\n    }\n  });\n};\n\nconst IsBrowser = typeof window !== \"undefined\";\n\nconst ProvideTagHashPlugin = () => {\n  return defineHeadPlugin({\n    hooks: {\n      \"tag:normalise\": (ctx) => {\n        const { tag, entry } = ctx;\n        if (!HasElementTags.includes(tag.tag))\n          return;\n        const isBrowser = IsBrowser || getActiveHead()?.resolvedOptions?.document;\n        if (!isBrowser && entry._m === \"server\" && tag.key)\n          tag.props[\"data-h-key\"] = tag._d;\n      }\n    }\n  });\n};\n\nconst PatchDomOnEntryUpdatesPlugin = (options) => {\n  return defineHeadPlugin({\n    hooks: {\n      \"entries:updated\": function(head) {\n        if (typeof options?.document === \"undefined\" && typeof window === \"undefined\")\n          return;\n        let delayFn = options?.delayFn;\n        if (!delayFn && typeof requestAnimationFrame !== \"undefined\")\n          delayFn = requestAnimationFrame;\n        import('@unhead/dom').then(({ debouncedRenderDOMHead }) => {\n          debouncedRenderDOMHead(head, { document: options?.document || window.document, delayFn });\n        });\n      }\n    }\n  });\n};\n\nconst EventHandlersPlugin = () => {\n  const stripEventHandlers = (tag) => {\n    const props = {};\n    const eventHandlers = {};\n    Object.entries(tag.props).forEach(([key, value]) => {\n      if (key.startsWith(\"on\") && typeof value === \"function\")\n        eventHandlers[key] = value;\n      else\n        props[key] = value;\n    });\n    return { props, eventHandlers };\n  };\n  return defineHeadPlugin({\n    hooks: {\n      \"ssr:render\": function(ctx) {\n        ctx.tags = ctx.tags.map((tag) => {\n          tag.props = stripEventHandlers(tag).props;\n          return tag;\n        });\n      },\n      \"dom:beforeRenderTag\": function(ctx) {\n        const { props, eventHandlers } = stripEventHandlers(ctx.tag);\n        if (!Object.keys(eventHandlers).length)\n          return;\n        ctx.tag.props = props;\n        ctx.tag._eventHandlers = eventHandlers;\n      },\n      \"dom:renderTag\": function(ctx) {\n        const $el = ctx.$el;\n        if (!ctx.tag._eventHandlers || !$el)\n          return;\n        Object.entries(ctx.tag._eventHandlers).forEach(([k, value]) => {\n          const sdeKey = `${ctx.tag._d || ctx.tag._p}:${k}`;\n          const eventName = k.slice(2).toLowerCase();\n          const handler = value;\n          $el?.addEventListener(eventName, handler);\n          ctx.entry._sde[sdeKey] = () => {\n            $el.removeEventListener(eventName, handler);\n          };\n          delete ctx.queuedSideEffects[sdeKey];\n        });\n      }\n    }\n  });\n};\n\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nlet activeHead;\nconst setActiveHead = (head) => activeHead = head;\nconst getActiveHead = () => activeHead;\n\nfunction useHead(input, options = {}) {\n  const head = getActiveHead();\n  const isBrowser = IsBrowser || head.resolvedOptions?.document;\n  if (options.mode === \"server\" && isBrowser || options.mode === \"client\" && !isBrowser)\n    return;\n  head.push(input, options);\n}\nconst useTagTitle = (title) => {\n  useHead({ title });\n};\nconst useTagBase = (base) => {\n  useHead({ base });\n};\nconst useTagMeta = (meta) => {\n  useHead({ meta: asArray(meta) });\n};\nconst useTagMetaFlat = (meta) => {\n  useTagMeta(unpackMeta(meta));\n};\nconst useTagLink = (link) => {\n  useHead({ link: asArray(link) });\n};\nconst useTagScript = (script) => {\n  useHead({ script: asArray(script) });\n};\nconst useTagStyle = (style) => {\n  useHead({ style: asArray(style) });\n};\nconst useTagNoscript = (noscript) => {\n  useHead({ noscript: asArray(noscript) });\n};\nconst useHtmlAttrs = (attrs) => {\n  useHead({ htmlAttrs: attrs });\n};\nconst useBodyAttrs = (attrs) => {\n  useHead({ bodyAttrs: attrs });\n};\nconst useTitleTemplate = (titleTemplate) => {\n  useHead({ titleTemplate });\n};\n\nfunction useServerHead(input, options = {}) {\n  useHead(input, { ...options, mode: \"server\" });\n}\nconst useServerTagTitle = (title) => {\n  useServerHead({ title });\n};\nconst useServerTagBase = (base) => {\n  useServerHead({ base });\n};\nconst useServerTagMeta = (meta) => {\n  useServerHead({ meta: asArray(meta) });\n};\nconst useServerTagMetaFlat = (meta) => {\n  useServerTagMeta(unpackMeta(meta));\n};\nconst useServerTagLink = (link) => {\n  useServerHead({ link: asArray(link) });\n};\nconst useServerTagScript = (script) => {\n  useServerHead({ script: asArray(script) });\n};\nconst useServerTagStyle = (style) => {\n  useServerHead({ style: asArray(style) });\n};\nconst useServerTagNoscript = (noscript) => {\n  useServerHead({ noscript: asArray(noscript) });\n};\nconst useServerHtmlAttrs = (attrs) => {\n  useServerHead({ htmlAttrs: attrs });\n};\nconst useServerBodyAttrs = (attrs) => {\n  useServerHead({ bodyAttrs: attrs });\n};\nconst useServerTitleTemplate = (titleTemplate) => {\n  useServerHead({ titleTemplate });\n};\n\nconst TagEntityBits = 10;\n\nfunction normaliseEntryTags(e) {\n  return Object.entries(e.input).filter(([k, v]) => typeof v !== \"undefined\" && ValidHeadTags.includes(k)).map(\n    ([k, value]) => asArray(value).map((props) => asArray(normaliseTag(k, props)))\n  ).flat(3).map((t, i) => {\n    t._e = e._i;\n    t._p = (e._i << TagEntityBits) + i;\n    return t;\n  });\n}\n\nfunction createHead(options = {}) {\n  let entries = [];\n  let _sde = {};\n  let _eid = 0;\n  const hooks = createHooks();\n  if (options?.hooks)\n    hooks.addHooks(options.hooks);\n  options.plugins = [\n    DeprecatedTagAttrPlugin(),\n    DedupesTagsPlugin(),\n    SortTagsPlugin(),\n    TitleTemplatePlugin(),\n    EventHandlersPlugin(),\n    ProvideTagHashPlugin(),\n    PatchDomOnEntryUpdatesPlugin({ document: options?.document, delayFn: options?.domDelayFn }),\n    ...options?.plugins || []\n  ];\n  options.plugins.forEach((p) => p.hooks && hooks.addHooks(p.hooks));\n  const triggerUpdateHook = () => hooks.callHook(\"entries:updated\", head);\n  const head = {\n    resolvedOptions: options,\n    _popSideEffectQueue() {\n      const sde = { ..._sde };\n      _sde = {};\n      return sde;\n    },\n    headEntries() {\n      return entries;\n    },\n    get hooks() {\n      return hooks;\n    },\n    push(input, options2) {\n      const activeEntry = {\n        _i: _eid++,\n        input,\n        _sde: {}\n      };\n      if (options2?.mode)\n        activeEntry._m = options2?.mode;\n      entries.push(activeEntry);\n      triggerUpdateHook();\n      const queueSideEffects = (e) => {\n        _sde = { ..._sde, ...e._sde || {} };\n        e._sde = {};\n        triggerUpdateHook();\n      };\n      return {\n        dispose() {\n          entries = entries.filter((e) => {\n            if (e._i !== activeEntry._i)\n              return true;\n            queueSideEffects(e);\n            return false;\n          });\n        },\n        patch(input2) {\n          entries = entries.map((e) => {\n            if (e._i === activeEntry._i) {\n              queueSideEffects(e);\n              activeEntry.input = e.input = input2;\n              activeEntry._i = e._i = _eid++;\n            }\n            return e;\n          });\n        }\n      };\n    },\n    async resolveTags() {\n      const resolveCtx = { tags: [], entries: [...entries] };\n      await hooks.callHook(\"entries:resolve\", resolveCtx);\n      for (const entry of resolveCtx.entries) {\n        for (const tag of normaliseEntryTags(entry)) {\n          const tagCtx = { tag, entry };\n          await hooks.callHook(\"tag:normalise\", tagCtx);\n          resolveCtx.tags.push(tagCtx.tag);\n        }\n      }\n      await hooks.callHook(\"tags:resolve\", resolveCtx);\n      return resolveCtx.tags;\n    }\n  };\n  head.hooks.callHook(\"init\", head);\n  setActiveHead(head);\n  return head;\n}\n\nfunction defineHeadPlugin(plugin) {\n  return plugin;\n}\n\nexport { DedupesTagsPlugin, DeprecatedTagAttrPlugin, EventHandlersPlugin, PatchDomOnEntryUpdatesPlugin, ProvideTagHashPlugin, SortTagsPlugin, TitleTemplatePlugin, activeHead, asArray, createHead, defineHeadPlugin, getActiveHead, normaliseEntryTags, setActiveHead, useBodyAttrs, useHead, useHtmlAttrs, useServerBodyAttrs, useServerHead, useServerHtmlAttrs, useServerTagBase, useServerTagLink, useServerTagMeta, useServerTagMetaFlat, useServerTagNoscript, useServerTagScript, useServerTagStyle, useServerTagTitle, useServerTitleTemplate, useTagBase, useTagLink, useTagMeta, useTagMetaFlat, useTagNoscript, useTagScript, useTagStyle, useTagTitle, useTitleTemplate };\n", "import { resolveUnref } from '@vueuse/shared';\nimport { unref, version, getCurrentInstance, inject, nextTick, ref, watchEffect, watch, onBeforeUnmount } from 'vue';\nimport { getActiveHead, createHead as createHead$1, defineHeadPlugin } from 'unhead';\nexport * from '@unhead/dom';\n\nfunction resolveUnrefHeadInput(ref) {\n  const root = resolveUnref(ref);\n  if (!ref || !root)\n    return root;\n  if (Array.isArray(root))\n    return root.map(resolveUnrefHeadInput);\n  if (typeof root === \"object\") {\n    return Object.fromEntries(\n      Object.entries(root).map(([key, value]) => {\n        if (key === \"titleTemplate\" || key.startsWith(\"on\"))\n          return [key, unref(value)];\n        return [key, resolveUnrefHeadInput(value)];\n      })\n    );\n  }\n  return root;\n}\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nconst Vue3 = version.startsWith(\"3\");\nconst IsBrowser = typeof window !== \"undefined\";\n\nconst headSymbol = \"usehead\";\nfunction injectHead() {\n  return getCurrentInstance() && inject(headSymbol) || getActiveHead();\n}\nfunction createHead(options = {}) {\n  const plugins = [\n    VueReactiveUseHeadPlugin(),\n    ...options?.plugins || []\n  ];\n  const head = createHead$1({\n    ...options,\n    domDelayFn: (fn) => setTimeout(() => nextTick(() => fn()), 10),\n    plugins\n  });\n  head.install = (app) => {\n    if (Vue3) {\n      app.config.globalProperties.$unhead = head;\n      app.provide(headSymbol, head);\n    }\n  };\n  return head;\n}\n\nconst VueHeadMixin = {\n  created() {\n    const instance = getCurrentInstance();\n    if (!instance)\n      return;\n    const options = instance.type;\n    if (!options || !(\"head\" in options))\n      return;\n    const source = typeof options.head === \"function\" ? () => options.head() : options.head;\n    useHead(source);\n  }\n};\n\nconst VueReactiveUseHeadPlugin = () => {\n  return defineHeadPlugin({\n    hooks: {\n      \"entries:resolve\": function(ctx) {\n        for (const entry of ctx.entries)\n          entry.input = resolveUnrefHeadInput(entry.input);\n      }\n    }\n  });\n};\n\nconst Vue2ProvideUnheadPlugin = function(_Vue, head) {\n  _Vue.mixin({\n    beforeCreate() {\n      const options = this.$options;\n      const origProvide = options.provide;\n      options.provide = function() {\n        let origProvideResult;\n        if (typeof origProvide === \"function\")\n          origProvideResult = origProvide.call(this);\n        else\n          origProvideResult = origProvide || {};\n        return {\n          ...origProvideResult,\n          [headSymbol]: head\n        };\n      };\n    }\n  });\n};\n\nfunction unpackToArray(input, options) {\n  const unpacked = [];\n  const kFn = options.resolveKeyData || ((ctx) => ctx.key);\n  const vFn = options.resolveValueData || ((ctx) => ctx.value);\n  for (const [k, v] of Object.entries(input)) {\n    unpacked.push(...(Array.isArray(v) ? v : [v]).map((i) => {\n      const ctx = { key: k, value: i };\n      const val = vFn(ctx);\n      if (typeof val === \"object\")\n        return unpackToArray(val, options);\n      if (Array.isArray(val))\n        return val;\n      return {\n        [typeof options.key === \"function\" ? options.key(ctx) : options.key]: kFn(ctx),\n        [typeof options.value === \"function\" ? options.value(ctx) : options.value]: val\n      };\n    }).flat());\n  }\n  return unpacked;\n}\n\nfunction unpackToString(value, options) {\n  return Object.entries(value).map(([key, value2]) => {\n    if (typeof value2 === \"object\")\n      value2 = unpackToString(value2, options);\n    if (options.resolve) {\n      const resolved = options.resolve({ key, value: value2 });\n      if (resolved)\n        return resolved;\n    }\n    if (typeof value2 === \"number\")\n      value2 = value2.toString();\n    if (typeof value2 === \"string\" && options.wrapValue) {\n      value2 = value2.replace(new RegExp(options.wrapValue, \"g\"), `\\\\${options.wrapValue}`);\n      value2 = `${options.wrapValue}${value2}${options.wrapValue}`;\n    }\n    return `${key}${options.keyValueSeparator || \"\"}${value2}`;\n  }).join(options.entrySeparator || \"\");\n}\n\nconst MetaPackingSchema = {\n  robots: {\n    unpack: {\n      keyValueSeparator: \":\"\n    }\n  },\n  contentSecurityPolicy: {\n    unpack: {\n      keyValueSeparator: \" \",\n      entrySeparator: \"; \"\n    },\n    metaKey: \"http-equiv\"\n  },\n  fbAppId: {\n    keyValue: \"fb:app_id\",\n    metaKey: \"property\"\n  },\n  msapplicationTileImage: {\n    keyValue: \"msapplication-TileImage\"\n  },\n  msapplicationTileColor: {\n    keyValue: \"msapplication-TileColor\"\n  },\n  msapplicationConfig: {\n    keyValue: \"msapplication-Config\"\n  },\n  charset: {\n    metaKey: \"charset\"\n  },\n  contentType: {\n    metaKey: \"http-equiv\"\n  },\n  defaultStyle: {\n    metaKey: \"http-equiv\"\n  },\n  xUaCompatible: {\n    metaKey: \"http-equiv\"\n  },\n  refresh: {\n    metaKey: \"http-equiv\"\n  }\n};\nfunction resolveMetaKeyType(key) {\n  return PropertyPrefixKeys.test(key) ? \"property\" : MetaPackingSchema[key]?.metaKey || \"name\";\n}\n\nfunction unpackMeta(input) {\n  return unpackToArray(input, {\n    key({ key }) {\n      return resolveMetaKeyType(key);\n    },\n    value({ key }) {\n      return key === \"charset\" ? \"charset\" : \"content\";\n    },\n    resolveKeyData({ key }) {\n      return MetaPackingSchema[key]?.keyValue || fixKeyCase(key);\n    },\n    resolveValueData({ value, key }) {\n      if (typeof value === \"object\") {\n        const definition = MetaPackingSchema[key];\n        if (key === \"refresh\")\n          return `${value.seconds};url=${value.url}`;\n        return unpackToString(\n          changeKeyCasingDeep(value),\n          {\n            entrySeparator: \", \",\n            keyValueSeparator: \"=\",\n            resolve({ value: value2, key: key2 }) {\n              if (typeof value2 === \"boolean\")\n                return `${key2}`;\n            },\n            ...definition?.unpack\n          }\n        );\n      }\n      return typeof value === \"number\" ? value.toString() : value;\n    }\n  });\n}\n\nconst PropertyPrefixKeys = /^(og|twitter|fb)/;\nfunction fixKeyCase(key) {\n  key = key.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  if (PropertyPrefixKeys.test(key)) {\n    key = key.replace(\"secure-url\", \"secure_url\").replace(/-/g, \":\");\n  }\n  return key;\n}\nfunction changeKeyCasingDeep(input) {\n  if (Array.isArray(input)) {\n    return input.map((entry) => changeKeyCasingDeep(entry));\n  }\n  if (typeof input !== \"object\" || Array.isArray(input))\n    return input;\n  const output = {};\n  for (const [key, value] of Object.entries(input))\n    output[fixKeyCase(key)] = changeKeyCasingDeep(value);\n  return output;\n}\n\nfunction clientUseHead(input, options = {}) {\n  const head = injectHead();\n  const vm = getCurrentInstance();\n  if (!vm) {\n    head.push(input, options);\n    return;\n  }\n  const resolvedInput = ref({});\n  watchEffect(() => {\n    resolvedInput.value = resolveUnrefHeadInput(input);\n  });\n  let entry;\n  watch(resolvedInput, (e) => {\n    if (!entry)\n      entry = head.push(e, options);\n    else\n      entry.patch(e);\n  }, { immediate: true });\n  onBeforeUnmount(() => {\n    entry?.dispose();\n  });\n}\n\nfunction serverUseHead(input, options = {}) {\n  const head = injectHead();\n  head.push(input, options);\n}\n\nfunction useServerHead(input, options = {}) {\n  useHead(input, { ...options, mode: \"server\" });\n}\nconst useServerTagTitle = (title) => useServerHead({ title });\nconst useServerTitleTemplate = (titleTemplate) => useServerHead({ titleTemplate });\nconst useServerTagMeta = (meta) => useServerHead({ meta: asArray(meta) });\nconst useServerTagMetaFlat = (meta) => {\n  const input = ref({});\n  watchEffect(() => {\n    input.value = unpackMeta(resolveUnrefHeadInput(meta));\n  });\n  return useServerHead({ meta: input });\n};\nconst useServerTagLink = (link) => useServerHead({ link: asArray(link) });\nconst useServerTagScript = (script) => useServerHead({ script: asArray(script) });\nconst useServerTagStyle = (style) => useServerHead({ style: asArray(style) });\nconst useServerTagNoscript = (noscript) => useServerHead({ noscript: asArray(noscript) });\nconst useServerTagBase = (base) => useServerHead({ base });\nconst useServerHtmlAttrs = (attrs) => useServerHead({ htmlAttrs: attrs });\nconst useServerBodyAttrs = (attrs) => useHead({ bodyAttrs: attrs });\n\nfunction useHead(input, options = {}) {\n  const head = injectHead();\n  const isBrowser = IsBrowser || head.resolvedOptions?.document;\n  if (options.mode === \"server\" && isBrowser || options.mode === \"client\" && !isBrowser)\n    return;\n  IsBrowser ? clientUseHead(input, options) : serverUseHead(input, options);\n}\nconst useTagTitle = (title) => useHead({ title });\nconst useTitleTemplate = (titleTemplate) => useHead({ titleTemplate });\nconst useTagMeta = (meta) => useHead({ meta: asArray(meta) });\nconst useTagMetaFlat = (meta) => {\n  const input = ref({});\n  watchEffect(() => {\n    input.value = unpackMeta(resolveUnrefHeadInput(meta));\n  });\n  return useHead({ meta: input });\n};\nconst useTagLink = (link) => useHead({ link: asArray(link) });\nconst useTagScript = (script) => useHead({ script: asArray(script) });\nconst useTagStyle = (style) => useHead({ style: asArray(style) });\nconst useTagNoscript = (noscript) => useHead({ noscript: asArray(noscript) });\nconst useTagBase = (base) => useHead({ base });\nconst useHtmlAttrs = (attrs) => useHead({ htmlAttrs: attrs });\nconst useBodyAttrs = (attrs) => useHead({ bodyAttrs: attrs });\n\nexport { Vue2ProvideUnheadPlugin, VueHeadMixin, VueReactiveUseHeadPlugin, asArray, createHead, headSymbol, injectHead, resolveUnrefHeadInput, useBodyAttrs, useHead, useHtmlAttrs, useServerBodyAttrs, useServerHead, useServerHtmlAttrs, useServerTagBase, useServerTagLink, useServerTagMeta, useServerTagMetaFlat, useServerTagNoscript, useServerTagScript, useServerTagStyle, useServerTagTitle, useServerTitleTemplate, useTagBase, useTagLink, useTagMeta, useTagMetaFlat, useTagNoscript, useTagScript, useTagStyle, useTagTitle, useTitleTemplate };\n", "const SelfClosingTags = [\"meta\", \"link\", \"base\"];\n\nconst propsToString = (props) => {\n  const handledAttributes = [];\n  for (const [key, value] of Object.entries(props)) {\n    if (value === false || value == null)\n      continue;\n    let attribute = key;\n    if (value !== true)\n      attribute += `=\"${String(value).replace(/\"/g, \"&quot;\")}\"`;\n    handledAttributes.push(attribute);\n  }\n  return handledAttributes.length > 0 ? ` ${handledAttributes.join(\" \")}` : \"\";\n};\n\nconst tagToString = (tag) => {\n  const attrs = propsToString(tag.props);\n  const openTag = `<${tag.tag}${attrs}>`;\n  return SelfClosingTags.includes(tag.tag) ? openTag : `${openTag}${tag.children || \"\"}</${tag.tag}>`;\n};\n\nfunction ssrRenderTags(tags) {\n  const schema = { htmlAttrs: {}, bodyAttrs: {}, tags: { head: [], bodyClose: [], bodyOpen: [] } };\n  for (const tag of tags) {\n    if (tag.tag === \"htmlAttrs\" || tag.tag === \"bodyAttrs\") {\n      schema[tag.tag] = { ...schema[tag.tag], ...tag.props };\n      continue;\n    }\n    schema.tags[tag.tagPosition || \"head\"].push(tagToString(tag));\n  }\n  return {\n    headTags: schema.tags.head.join(\"\\n\"),\n    bodyTags: schema.tags.bodyClose.join(\"\\n\"),\n    bodyTagsOpen: schema.tags.bodyOpen.join(\"\\n\"),\n    htmlAttrs: propsToString(schema.htmlAttrs),\n    bodyAttrs: propsToString(schema.bodyAttrs)\n  };\n}\n\nasync function renderSSRHead(head) {\n  const beforeRenderCtx = { shouldRender: true };\n  await head.hooks.callHook(\"ssr:beforeRender\", beforeRenderCtx);\n  if (!beforeRenderCtx.shouldRender) {\n    return {\n      headTags: \"\",\n      bodyTags: \"\",\n      bodyTagsOpen: \"\",\n      htmlAttrs: \"\",\n      bodyAttrs: \"\"\n    };\n  }\n  const ctx = { tags: await head.resolveTags() };\n  await head.hooks.callHook(\"ssr:render\", ctx);\n  const html = ssrRenderTags(ctx.tags);\n  const renderCtx = { tags: ctx.tags, html };\n  await head.hooks.callHook(\"ssr:rendered\", renderCtx);\n  return renderCtx.html;\n}\n\nexport { renderSSRHead };\n", "import { createHead as createHead$1, renderDOMHead, debouncedRenderDOMHead, Vue2ProvideUnheadPlugin, injectHead } from '@unhead/vue';\nexport { VueHeadMixin, useHead, useServerHead } from '@unhead/vue';\nimport { renderSSRHead } from '@unhead/ssr';\nimport { version, defineComponent, ref, onBeforeUnmount, watchEffect } from 'vue';\n\nfunction createHead(initHeadObject) {\n  const head = createHead$1();\n  const legacyHead = {\n    headTags() {\n      return head.resolveTags();\n    },\n    addHeadObjs(input, options) {\n      return head.push(input, options);\n    },\n    updateDOM(document, force) {\n      if (force)\n        renderDOMHead(head, { document });\n      else\n        debouncedRenderDOMHead(head, { delayFn: (fn) => setTimeout(() => fn(), 50), document });\n    }\n  };\n  head.headTags = legacyHead.headTags;\n  head.addHeadObjs = legacyHead.addHeadObjs;\n  head.updateDOM = legacyHead.updateDOM;\n  if (initHeadObject)\n    head.push(initHeadObject);\n  return head;\n}\n\nconst HeadVuePlugin = Vue2ProvideUnheadPlugin;\nconst renderHeadToString = (head) => renderSSRHead(head);\n\nconst Vue2 = version.startsWith(\"2.\");\nconst IsBrowser = typeof window !== \"undefined\";\n\nconst addVNodeToHeadObj = (node, obj) => {\n  const nodeType = Vue2 ? node.tag : node.type;\n  const type = nodeType === \"html\" ? \"htmlAttrs\" : nodeType === \"body\" ? \"bodyAttrs\" : nodeType;\n  if (typeof type !== \"string\" || !(type in obj))\n    return;\n  const nodeData = Vue2 ? node.data : node;\n  const props = (Vue2 ? nodeData.attrs : node.props) || {};\n  if (Vue2) {\n    if (nodeData.staticClass)\n      props.class = nodeData.staticClass;\n    if (nodeData.staticStyle)\n      props.style = Object.entries(nodeData.staticStyle).map(([key, value]) => `${key}:${value}`).join(\";\");\n  }\n  if (node.children) {\n    const childrenAttr = Vue2 ? \"text\" : \"children\";\n    props.children = Array.isArray(node.children) ? node.children[0][childrenAttr] : node[childrenAttr];\n  }\n  if (Array.isArray(obj[type]))\n    obj[type].push(props);\n  else if (type === \"title\")\n    obj.title = props.children;\n  else\n    obj[type] = props;\n};\nconst vnodesToHeadObj = (nodes) => {\n  const obj = {\n    title: void 0,\n    htmlAttrs: void 0,\n    bodyAttrs: void 0,\n    base: void 0,\n    meta: [],\n    link: [],\n    style: [],\n    script: [],\n    noscript: []\n  };\n  for (const node of nodes) {\n    if (typeof node.type === \"symbol\" && Array.isArray(node.children)) {\n      for (const childNode of node.children)\n        addVNodeToHeadObj(childNode, obj);\n    } else {\n      addVNodeToHeadObj(node, obj);\n    }\n  }\n  return obj;\n};\nconst Head = /* @__PURE__ */ defineComponent({\n  name: \"Head\",\n  setup(_, { slots }) {\n    const head = injectHead();\n    const obj = ref({});\n    const entry = head.push(obj);\n    if (IsBrowser) {\n      onBeforeUnmount(() => {\n        entry.dispose();\n      });\n    }\n    return () => {\n      watchEffect(() => {\n        if (!slots.default)\n          return;\n        entry.patch(vnodesToHeadObj(slots.default()));\n      });\n      return null;\n    };\n  }\n});\n\nexport { Head, HeadVuePlugin, createHead, renderHeadToString };\n"],
  "mappings": "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",
  "names": ["debouncedRenderDOMHead", "ref", "IsBrowser", "createHead", "IsBrowser", "createHead", "document", "IsBrowser"]
}
