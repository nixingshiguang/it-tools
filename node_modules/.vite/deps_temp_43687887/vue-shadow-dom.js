import "./chunk-NQAK2E44.js";
import {
  Teleport,
  computed,
  defineComponent,
  h,
  onBeforeMount,
  onMounted,
  reactive,
  ref,
  watch
} from "./chunk-INQX4MOS.js";
import "./chunk-2LSFTFF7.js";

// node_modules/.pnpm/vue-shadow-dom@4.2.0/node_modules/vue-shadow-dom/shadow.mjs
function makeShadow(el, option) {
  return makeShadowRaw(el, el.childNodes, option);
}
function makeShadowRaw(rootEl, childNodes, { mode = "open", delegatesFocus = false } = { mode: "open" }) {
  try {
    const oldroot = rootEl.shadowRoot;
    if (oldroot != null) {
      console.error("[shadow] Attach shadow multiple times", rootEl, childNodes, oldroot);
      return;
    } else {
      const shadow_root = rootEl.attachShadow({ mode, delegatesFocus });
      if (childNodes)
        putDomIntoShadow(shadow_root, childNodes);
      return shadow_root;
    }
  } catch (e) {
    console.error("[shadow] make shadow-root failed", rootEl, childNodes);
    console.error(e);
  }
}
function putDomIntoShadow(shadow_root, childNodes) {
  const fragment = document.createDocumentFragment();
  for (const node of childNodes) {
    fragment.appendChild(node);
  }
  shadow_root.appendChild(fragment);
}
var virtual_root = document.createDocumentFragment();
var ShadowStyle = defineComponent({
  props: {
    media: String,
    nonce: String
  },
  setup(props, { slots }) {
    return () => {
      var _a;
      return h("style", { media: props.media, nonce: props.nonce }, (_a = slots.default) == null ? void 0 : _a.call(slots));
    };
  }
});
var ShadowRoot = withType()(defineComponent({
  props: {
    mode: {
      type: String,
      default: "open"
    },
    delegatesFocus: {
      type: Boolean,
      default: false
    },
    abstract: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: "div"
    },
    adoptedStyleSheets: {
      type: Array
    }
  },
  emits: ["error"],
  setup(props, { slots, expose, emit }) {
    const abstract = ref(false);
    const el = ref();
    const teleport_el = ref();
    const shadow_root = ref();
    const teleport_target = computed(() => shadow_root.value ?? virtual_root);
    const ex = reactive({
      shadow_root
    });
    expose(ex);
    onBeforeMount(() => {
      abstract.value = props.abstract;
    });
    onMounted(() => {
      var _a;
      try {
        if (abstract.value) {
          if (teleport_el.value.parentElement.shadowRoot) {
            shadow_root.value = teleport_el.value.parentElement.shadowRoot;
          } else {
            shadow_root.value = makeShadowRaw(teleport_el.value.parentElement, void 0, {
              mode: props.mode,
              delegatesFocus: props.delegatesFocus
            });
          }
        } else {
          shadow_root.value = makeShadowRaw(el.value, void 0, { mode: props.mode, delegatesFocus: props.delegatesFocus });
        }
        (_a = shadow_root.value) == null ? void 0 : _a.styleSheets;
      } catch (e) {
        console.error(e);
        emit("error", e);
      }
    });
    watch([shadow_root, () => props.adoptedStyleSheets], ([shadow_root2, adoptedStyleSheets]) => {
      if (!shadow_root2 || !adoptedStyleSheets)
        return;
      try {
        ;
        shadow_root2.adoptedStyleSheets = adoptedStyleSheets;
      } catch (e) {
        console.error(e);
        emit("error", e);
      }
    });
    return () => {
      var _a;
      const child_part = h(Teleport, { ref: teleport_el, to: teleport_target.value }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      if (abstract.value)
        return child_part;
      return h(props.tag, { ref: el }, child_part);
    };
  },
  install,
  Style: ShadowStyle
}));
function withType() {
  return (obj) => obj;
}
function install(app) {
  app.component("shadow-root", ShadowRoot);
  app.directive("shadow", {
    beforeMount(el) {
      console.warn("[VueShadowDom] Deprecated v-shadow directive, use <shadow-root> component");
      makeShadow(el);
    }
  });
}
var shadow = { ShadowRoot, ShadowStyle, shadow_root: ShadowRoot, shadow_style: ShadowStyle, install };
export {
  ShadowRoot,
  ShadowStyle,
  shadow as default,
  install,
  makeShadow,
  makeShadowRaw,
  ShadowRoot as shadow_root,
  ShadowStyle as shadow_style
};
//# sourceMappingURL=vue-shadow-dom.js.map
