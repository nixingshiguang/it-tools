{
  "version": 3,
  "sources": ["../../.pnpm/@it-tools+oggen@1.3.0/node_modules/@it-tools/oggen/dist/index.mjs"],
  "sourcesContent": ["const twitterCompatibility = {\n  \"og:description\": \"twitter:description\",\n  \"og:title\": \"twitter:title\",\n  \"og:image\": \"twitter:image\",\n  \"og:image:url\": \"twitter:image\",\n  \"og:image:alt\": \"twitter:image:alt\"\n};\nfunction pickTwitterCompatibleMetadata({ existingMeta, twitterMeta }) {\n  return existingMeta.filter(({ key }) => key in twitterCompatibility && twitterMeta.find((tm) => tm.key === twitterCompatibility[key]) === void 0).map(({ key, value }) => ({ key: twitterCompatibility[key] ?? key, value }));\n}\n\nconst isObject = (v) => typeof v === \"object\" && !Array.isArray(v) && v !== null && !(v instanceof Date);\nconst toSnakeCase = (s) => s.split(\":\").map(toSnakeCaseStrict).join(\":\");\nconst toSnakeCaseStrict = (s) => s.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)?.map((x) => x.toLowerCase()).join(\"_\") ?? \"\";\n\nfunction generateMetaForType({ title, flatMetadata, type }) {\n  if (flatMetadata.length === 0)\n    return [];\n  return [`<!-- ${title} -->`, ...buildMetaStrings({ flatMetadata, type })];\n}\nfunction generateMeta({ twitter: twitterMetadataRaw, ...ogMetadataRaw }, { indentation = 0, indentWith = \"  \", generateTwitterCompatibleMeta = false } = {}) {\n  const ogMetadataFlat = flattenMetadata(ogMetadataRaw, { basePrefix: \"og\" });\n  const twitterMetadataFlat = flattenMetadata(twitterMetadataRaw, { basePrefix: \"twitter\" });\n  const metaStringGroups = [\n    generateMetaForType({\n      title: \"og meta\",\n      flatMetadata: ogMetadataFlat,\n      type: \"property\"\n    }),\n    generateMetaForType({\n      title: \"twitter meta\",\n      flatMetadata: [\n        ...twitterMetadataFlat,\n        ...generateTwitterCompatibleMeta ? pickTwitterCompatibleMetadata({ existingMeta: ogMetadataFlat, twitterMeta: twitterMetadataFlat }) : []\n      ],\n      type: \"name\"\n    })\n  ];\n  const metaGroups = metaStringGroups.filter((group) => group && group.length > 0).map((group) => group.map((str) => indentWith.repeat(indentation) + str).join(\"\\n\"));\n  return metaGroups.join(\"\\n\\n\");\n}\nfunction stringifyValue(value) {\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n  return String(value);\n}\nfunction flattenMetadata(metadata, { separator = \":\", basePrefix = \"\" } = {}) {\n  const acc = [];\n  const walk = (node, prefix = \"\") => {\n    if (node === void 0 || node === \"\")\n      return;\n    if (isObject(node)) {\n      for (const [key, value] of Object.entries(node)) {\n        const prefixedKey = [prefix, toSnakeCase(key)].filter(Boolean).join(separator);\n        walk(value, prefixedKey);\n      }\n    } else if (Array.isArray(node)) {\n      for (const value of node) {\n        walk(value, prefix);\n      }\n    } else {\n      acc.push({ key: prefix, value: stringifyValue(node) });\n    }\n  };\n  walk(metadata, basePrefix);\n  return acc;\n}\nfunction metaToString({ flatMetadata: { key, value }, type }) {\n  return `<meta ${type.trim()}=\"${key.trim()}\" value=\"${value.trim()}\" />`;\n}\nfunction buildMetaStrings({ flatMetadata, type }) {\n  return flatMetadata.map((flatMetadata2) => metaToString({ flatMetadata: flatMetadata2, type }));\n}\n\nexport { generateMeta };\n"],
  "mappings": "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",
  "names": []
}
